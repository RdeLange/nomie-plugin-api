import { pascalCase } from 'pascal-case';
import path from 'path';
import compiler from 'svelte/compiler';
import dedent from 'dedent-js';
import * as ts from 'typescript';
import ts__default, { createSourceFile, ScriptTarget, ScriptKind, isImportDeclaration, isInterfaceDeclaration, isVariableStatement, NodeFlags, isVariableDeclaration, isIdentifier as isIdentifier$1, isFunctionDeclaration, isClassDeclaration, isBlock, isArrowFunction, isExportDeclaration, isNamedExports, isCallExpression, isBindingElement, isImportClause, isImportSpecifier, isLabeledStatement, isTypeAssertionExpression, forEachChild, isBinaryExpression, SyntaxKind, isPrefixUnaryExpression, isPostfixUnaryExpression, isParameter, isPropertyAccessExpression, isPropertyAssignment, isPropertySignature, isPropertyDeclaration, isObjectBindingPattern, isArrayBindingPattern, isObjectLiteralExpression, getJSDocType } from 'typescript';

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
function encode(decoded) {
    var sourceFileIndex = 0; // second field
    var sourceCodeLine = 0; // third field
    var sourceCodeColumn = 0; // fourth field
    var nameIndex = 0; // fifth field
    var mappings = '';
    for (var i = 0; i < decoded.length; i++) {
        var line = decoded[i];
        if (i > 0)
            mappings += ';';
        if (line.length === 0)
            continue;
        var generatedCodeColumn = 0; // first field
        var lineMappings = [];
        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
            var segment = line_1[_i];
            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
            generatedCodeColumn = segment[0];
            if (segment.length > 1) {
                segmentMappings +=
                    encodeInteger(segment[1] - sourceFileIndex) +
                        encodeInteger(segment[2] - sourceCodeLine) +
                        encodeInteger(segment[3] - sourceCodeColumn);
                sourceFileIndex = segment[1];
                sourceCodeLine = segment[2];
                sourceCodeColumn = segment[3];
            }
            if (segment.length === 5) {
                segmentMappings += encodeInteger(segment[4] - nameIndex);
                nameIndex = segment[4];
            }
            lineMappings.push(segmentMappings);
        }
        mappings += lineMappings.join(',');
    }
    return mappings;
}
function encodeInteger(num) {
    var result = '';
    num = num < 0 ? (-num << 1) | 1 : num << 1;
    do {
        var clamped = num & 31;
        num >>>= 5;
        if (num > 0) {
            clamped |= 32;
        }
        result += chars[clamped];
    } while (num > 0);
    return result;
}

var BitSet = function BitSet(arg) {
	this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
};

BitSet.prototype.add = function add (n) {
	this.bits[n >> 5] |= 1 << (n & 31);
};

BitSet.prototype.has = function has (n) {
	return !!(this.bits[n >> 5] & (1 << (n & 31)));
};

var Chunk = function Chunk(start, end, content) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties(this, {
		previous: { writable: true, value: null },
		next:     { writable: true, value: null }
	});
};

Chunk.prototype.appendLeft = function appendLeft (content) {
	this.outro += content;
};

Chunk.prototype.appendRight = function appendRight (content) {
	this.intro = this.intro + content;
};

Chunk.prototype.clone = function clone () {
	var chunk = new Chunk(this.start, this.end, this.original);

	chunk.intro = this.intro;
	chunk.outro = this.outro;
	chunk.content = this.content;
	chunk.storeName = this.storeName;
	chunk.edited = this.edited;

	return chunk;
};

Chunk.prototype.contains = function contains (index) {
	return this.start < index && index < this.end;
};

Chunk.prototype.eachNext = function eachNext (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.next;
	}
};

Chunk.prototype.eachPrevious = function eachPrevious (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.previous;
	}
};

Chunk.prototype.edit = function edit (content, storeName, contentOnly) {
	this.content = content;
	if (!contentOnly) {
		this.intro = '';
		this.outro = '';
	}
	this.storeName = storeName;

	this.edited = true;

	return this;
};

Chunk.prototype.prependLeft = function prependLeft (content) {
	this.outro = content + this.outro;
};

Chunk.prototype.prependRight = function prependRight (content) {
	this.intro = content + this.intro;
};

Chunk.prototype.split = function split (index) {
	var sliceIndex = index - this.start;

	var originalBefore = this.original.slice(0, sliceIndex);
	var originalAfter = this.original.slice(sliceIndex);

	this.original = originalBefore;

	var newChunk = new Chunk(index, this.end, originalAfter);
	newChunk.outro = this.outro;
	this.outro = '';

	this.end = index;

	if (this.edited) {
		// TODO is this block necessary?...
		newChunk.edit('', false);
		this.content = '';
	} else {
		this.content = originalBefore;
	}

	newChunk.next = this.next;
	if (newChunk.next) { newChunk.next.previous = newChunk; }
	newChunk.previous = this;
	this.next = newChunk;

	return newChunk;
};

Chunk.prototype.toString = function toString () {
	return this.intro + this.content + this.outro;
};

Chunk.prototype.trimEnd = function trimEnd (rx) {
	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.start + trimmed.length).edit('', undefined, true);
		}
		return true;

	} else {
		this.edit('', undefined, true);

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; }
	}
};

Chunk.prototype.trimStart = function trimStart (rx) {
	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.end - trimmed.length);
			this.edit('', undefined, true);
		}
		return true;

	} else {
		this.edit('', undefined, true);

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; }
	}
};

var btoa = function () {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
};
if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
} else if (typeof Buffer === 'function') {
	btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
}

var SourceMap = function SourceMap(properties) {
	this.version = 3;
	this.file = properties.file;
	this.sources = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names = properties.names;
	this.mappings = encode(properties.mappings);
};

SourceMap.prototype.toString = function toString () {
	return JSON.stringify(this);
};

SourceMap.prototype.toUrl = function toUrl () {
	return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
};

function guessIndent(code) {
	var lines = code.split('\n');

	var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
	var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce(function (previous, current) {
		var numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	var fromParts = from.split(/[/\\]/);
	var toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		var i = fromParts.length;
		while (i--) { fromParts[i] = '..'; }
	}

	return fromParts.concat(toParts).join('/');
}

var toString = Object.prototype.toString;

function isObject(thing) {
	return toString.call(thing) === '[object Object]';
}

function getLocator(source) {
	var originalLines = source.split('\n');
	var lineOffsets = [];

	for (var i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		var i = 0;
		var j = lineOffsets.length;
		while (i < j) {
			var m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		var line = i - 1;
		var column = index - lineOffsets[line];
		return { line: line, column: column };
	};
}

var Mappings = function Mappings(hires) {
	this.hires = hires;
	this.generatedCodeLine = 0;
	this.generatedCodeColumn = 0;
	this.raw = [];
	this.rawSegments = this.raw[this.generatedCodeLine] = [];
	this.pending = null;
};

Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
	if (content.length) {
		var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
		if (nameIndex >= 0) {
			segment.push(nameIndex);
		}
		this.rawSegments.push(segment);
	} else if (this.pending) {
		this.rawSegments.push(this.pending);
	}

	this.advance(content);
	this.pending = null;
};

Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
	var originalCharIndex = chunk.start;
	var first = true;

	while (originalCharIndex < chunk.end) {
		if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
			this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
		}

		if (original[originalCharIndex] === '\n') {
			loc.line += 1;
			loc.column = 0;
			this.generatedCodeLine += 1;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
			this.generatedCodeColumn = 0;
			first = true;
		} else {
			loc.column += 1;
			this.generatedCodeColumn += 1;
			first = false;
		}

		originalCharIndex += 1;
	}

	this.pending = null;
};

Mappings.prototype.advance = function advance (str) {
	if (!str) { return; }

	var lines = str.split('\n');

	if (lines.length > 1) {
		for (var i = 0; i < lines.length - 1; i++) {
			this.generatedCodeLine++;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
		}
		this.generatedCodeColumn = 0;
	}

	this.generatedCodeColumn += lines[lines.length - 1].length;
};

var n = '\n';

var warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};

var MagicString = function MagicString(string, options) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk(0, string.length, string);

	Object.defineProperties(this, {
		original:              { writable: true, value: string },
		outro:                 { writable: true, value: '' },
		intro:                 { writable: true, value: '' },
		firstChunk:            { writable: true, value: chunk },
		lastChunk:             { writable: true, value: chunk },
		lastSearchedChunk:     { writable: true, value: chunk },
		byStart:               { writable: true, value: {} },
		byEnd:                 { writable: true, value: {} },
		filename:              { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations:    { writable: true, value: new BitSet() },
		storedNames:           { writable: true, value: {} },
		indentStr:             { writable: true, value: guessIndent(string) }
	});

	this.byStart[0] = chunk;
	this.byEnd[string.length] = chunk;
};

MagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
	this.sourcemapLocations.add(char);
};

MagicString.prototype.append = function append (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.outro += content;
	return this;
};

MagicString.prototype.appendLeft = function appendLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.appendLeft(content);
	} else {
		this.intro += content;
	}
	return this;
};

MagicString.prototype.appendRight = function appendRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.appendRight(content);
	} else {
		this.outro += content;
	}
	return this;
};

MagicString.prototype.clone = function clone () {
	var cloned = new MagicString(this.original, { filename: this.filename });

	var originalChunk = this.firstChunk;
	var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

	while (originalChunk) {
		cloned.byStart[clonedChunk.start] = clonedChunk;
		cloned.byEnd[clonedChunk.end] = clonedChunk;

		var nextOriginalChunk = originalChunk.next;
		var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

		if (nextClonedChunk) {
			clonedChunk.next = nextClonedChunk;
			nextClonedChunk.previous = clonedChunk;

			clonedChunk = nextClonedChunk;
		}

		originalChunk = nextOriginalChunk;
	}

	cloned.lastChunk = clonedChunk;

	if (this.indentExclusionRanges) {
		cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
	}

	cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

	cloned.intro = this.intro;
	cloned.outro = this.outro;

	return cloned;
};

MagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1 = this;

	options = options || {};

	var sourceIndex = 0;
	var names = Object.keys(this.storedNames);
	var mappings = new Mappings(options.hires);

	var locate = getLocator(this.original);

	if (this.intro) {
		mappings.advance(this.intro);
	}

	this.firstChunk.eachNext(function (chunk) {
		var loc = locate(chunk.start);

		if (chunk.intro.length) { mappings.advance(chunk.intro); }

		if (chunk.edited) {
			mappings.addEdit(
				sourceIndex,
				chunk.content,
				loc,
				chunk.storeName ? names.indexOf(chunk.original) : -1
			);
		} else {
			mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);
		}

		if (chunk.outro.length) { mappings.advance(chunk.outro); }
	});

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
		sourcesContent: options.includeContent ? [this.original] : [null],
		names: names,
		mappings: mappings.raw
	};
};

MagicString.prototype.generateMap = function generateMap (options) {
	return new SourceMap(this.generateDecodedMap(options));
};

MagicString.prototype.getIndentString = function getIndentString () {
	return this.indentStr === null ? '\t' : this.indentStr;
};

MagicString.prototype.indent = function indent (indentStr, options) {
	var pattern = /^[^\r\n]/gm;

	if (isObject(indentStr)) {
		options = indentStr;
		indentStr = undefined;
	}

	indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

	if (indentStr === '') { return this; } // noop

	options = options || {};

	// Process exclusion ranges
	var isExcluded = {};

	if (options.exclude) {
		var exclusions =
			typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
		exclusions.forEach(function (exclusion) {
			for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
				isExcluded[i] = true;
			}
		});
	}

	var shouldIndentNextCharacter = options.indentStart !== false;
	var replacer = function (match) {
		if (shouldIndentNextCharacter) { return ("" + indentStr + match); }
		shouldIndentNextCharacter = true;
		return match;
	};

	this.intro = this.intro.replace(pattern, replacer);

	var charIndex = 0;
	var chunk = this.firstChunk;

	while (chunk) {
		var end = chunk.end;

		if (chunk.edited) {
			if (!isExcluded[charIndex]) {
				chunk.content = chunk.content.replace(pattern, replacer);

				if (chunk.content.length) {
					shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
				}
			}
		} else {
			charIndex = chunk.start;

			while (charIndex < end) {
				if (!isExcluded[charIndex]) {
					var char = this.original[charIndex];

					if (char === '\n') {
						shouldIndentNextCharacter = true;
					} else if (char !== '\r' && shouldIndentNextCharacter) {
						shouldIndentNextCharacter = false;

						if (charIndex === chunk.start) {
							chunk.prependRight(indentStr);
						} else {
							this._splitChunk(chunk, charIndex);
							chunk = chunk.next;
							chunk.prependRight(indentStr);
						}
					}
				}

				charIndex += 1;
			}
		}

		charIndex = chunk.end;
		chunk = chunk.next;
	}

	this.outro = this.outro.replace(pattern, replacer);

	return this;
};

MagicString.prototype.insert = function insert () {
	throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
};

MagicString.prototype.insertLeft = function insertLeft (index, content) {
	if (!warned.insertLeft) {
		console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
		warned.insertLeft = true;
	}

	return this.appendLeft(index, content);
};

MagicString.prototype.insertRight = function insertRight (index, content) {
	if (!warned.insertRight) {
		console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
		warned.insertRight = true;
	}

	return this.prependRight(index, content);
};

MagicString.prototype.move = function move (start, end, index) {
	if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }

	this._split(start);
	this._split(end);
	this._split(index);

	var first = this.byStart[start];
	var last = this.byEnd[end];

	var oldLeft = first.previous;
	var oldRight = last.next;

	var newRight = this.byStart[index];
	if (!newRight && last === this.lastChunk) { return this; }
	var newLeft = newRight ? newRight.previous : this.lastChunk;

	if (oldLeft) { oldLeft.next = oldRight; }
	if (oldRight) { oldRight.previous = oldLeft; }

	if (newLeft) { newLeft.next = first; }
	if (newRight) { newRight.previous = last; }

	if (!first.previous) { this.firstChunk = last.next; }
	if (!last.next) {
		this.lastChunk = first.previous;
		this.lastChunk.next = null;
	}

	first.previous = newLeft;
	last.next = newRight || null;

	if (!newLeft) { this.firstChunk = first; }
	if (!newRight) { this.lastChunk = last; }
	return this;
};

MagicString.prototype.overwrite = function overwrite (start, end, content, options) {
	if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (end > this.original.length) { throw new Error('end is out of bounds'); }
	if (start === end)
		{ throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead'); }

	this._split(start);
	this._split(end);

	if (options === true) {
		if (!warned.storeName) {
			console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
			warned.storeName = true;
		}

		options = { storeName: true };
	}
	var storeName = options !== undefined ? options.storeName : false;
	var contentOnly = options !== undefined ? options.contentOnly : false;

	if (storeName) {
		var original = this.original.slice(start, end);
		this.storedNames[original] = true;
	}

	var first = this.byStart[start];
	var last = this.byEnd[end];

	if (first) {
		if (end > first.end && first.next !== this.byStart[first.end]) {
			throw new Error('Cannot overwrite across a split point');
		}

		first.edit(content, storeName, contentOnly);

		if (first !== last) {
			var chunk = first.next;
			while (chunk !== last) {
				chunk.edit('', false);
				chunk = chunk.next;
			}

			chunk.edit('', false);
		}
	} else {
		// must be inserting at the end
		var newChunk = new Chunk(start, end, '').edit(content, storeName);

		// TODO last chunk in the array may not be the last chunk, if it's moved...
		last.next = newChunk;
		newChunk.previous = last;
	}
	return this;
};

MagicString.prototype.prepend = function prepend (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.intro = content + this.intro;
	return this;
};

MagicString.prototype.prependLeft = function prependLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.prependLeft(content);
	} else {
		this.intro = content + this.intro;
	}
	return this;
};

MagicString.prototype.prependRight = function prependRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.prependRight(content);
	} else {
		this.outro = content + this.outro;
	}
	return this;
};

MagicString.prototype.remove = function remove (start, end) {
	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (start === end) { return this; }

	if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }
	if (start > end) { throw new Error('end must be greater than start'); }

	this._split(start);
	this._split(end);

	var chunk = this.byStart[start];

	while (chunk) {
		chunk.intro = '';
		chunk.outro = '';
		chunk.edit('');

		chunk = end > chunk.end ? this.byStart[chunk.end] : null;
	}
	return this;
};

MagicString.prototype.lastChar = function lastChar () {
	if (this.outro.length)
		{ return this.outro[this.outro.length - 1]; }
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length)
			{ return chunk.outro[chunk.outro.length - 1]; }
		if (chunk.content.length)
			{ return chunk.content[chunk.content.length - 1]; }
		if (chunk.intro.length)
			{ return chunk.intro[chunk.intro.length - 1]; }
	} while (chunk = chunk.previous);
	if (this.intro.length)
		{ return this.intro[this.intro.length - 1]; }
	return '';
};

MagicString.prototype.lastLine = function lastLine () {
	var lineIndex = this.outro.lastIndexOf(n);
	if (lineIndex !== -1)
		{ return this.outro.substr(lineIndex + 1); }
	var lineStr = this.outro;
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length > 0) {
			lineIndex = chunk.outro.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.outro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.outro + lineStr;
		}

		if (chunk.content.length > 0) {
			lineIndex = chunk.content.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.content.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.content + lineStr;
		}

		if (chunk.intro.length > 0) {
			lineIndex = chunk.intro.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.intro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.intro + lineStr;
		}
	} while (chunk = chunk.previous);
	lineIndex = this.intro.lastIndexOf(n);
	if (lineIndex !== -1)
		{ return this.intro.substr(lineIndex + 1) + lineStr; }
	return this.intro + lineStr;
};

MagicString.prototype.slice = function slice (start, end) {
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	var result = '';

	// find start chunk
	var chunk = this.firstChunk;
	while (chunk && (chunk.start > start || chunk.end <= start)) {
		// found end chunk before start
		if (chunk.start < end && chunk.end >= end) {
			return result;
		}

		chunk = chunk.next;
	}

	if (chunk && chunk.edited && chunk.start !== start)
		{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

	var startChunk = chunk;
	while (chunk) {
		if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
			result += chunk.intro;
		}

		var containsEnd = chunk.start < end && chunk.end >= end;
		if (containsEnd && chunk.edited && chunk.end !== end)
			{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

		var sliceStart = startChunk === chunk ? start - chunk.start : 0;
		var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

		result += chunk.content.slice(sliceStart, sliceEnd);

		if (chunk.outro && (!containsEnd || chunk.end === end)) {
			result += chunk.outro;
		}

		if (containsEnd) {
			break;
		}

		chunk = chunk.next;
	}

	return result;
};

// TODO deprecate this? not really very useful
MagicString.prototype.snip = function snip (start, end) {
	var clone = this.clone();
	clone.remove(0, start);
	clone.remove(end, clone.original.length);

	return clone;
};

MagicString.prototype._split = function _split (index) {
	if (this.byStart[index] || this.byEnd[index]) { return; }

	var chunk = this.lastSearchedChunk;
	var searchForward = index > chunk.end;

	while (chunk) {
		if (chunk.contains(index)) { return this._splitChunk(chunk, index); }

		chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
	}
};

MagicString.prototype._splitChunk = function _splitChunk (chunk, index) {
	if (chunk.edited && chunk.content.length) {
		// zero-length edited chunks are a special case (overlapping replacements)
		var loc = getLocator(this.original)(index);
		throw new Error(
			("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")")
		);
	}

	var newChunk = chunk.split(index);

	this.byEnd[index] = chunk;
	this.byStart[index] = newChunk;
	this.byEnd[newChunk.end] = newChunk;

	if (chunk === this.lastChunk) { this.lastChunk = newChunk; }

	this.lastSearchedChunk = chunk;
	return true;
};

MagicString.prototype.toString = function toString () {
	var str = this.intro;

	var chunk = this.firstChunk;
	while (chunk) {
		str += chunk.toString();
		chunk = chunk.next;
	}

	return str + this.outro;
};

MagicString.prototype.isEmpty = function isEmpty () {
	var chunk = this.firstChunk;
	do {
		if (chunk.intro.length && chunk.intro.trim() ||
				chunk.content.length && chunk.content.trim() ||
				chunk.outro.length && chunk.outro.trim())
			{ return false; }
	} while (chunk = chunk.next);
	return true;
};

MagicString.prototype.length = function length () {
	var chunk = this.firstChunk;
	var length = 0;
	do {
		length += chunk.intro.length + chunk.content.length + chunk.outro.length;
	} while (chunk = chunk.next);
	return length;
};

MagicString.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
};

MagicString.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
};

MagicString.prototype.trimEndAborted = function trimEndAborted (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var chunk = this.lastChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimEnd(rx);

		// if chunk was trimmed, we have a new lastChunk
		if (chunk.end !== end) {
			if (this.lastChunk === chunk) {
				this.lastChunk = chunk.next;
			}

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.previous;
	} while (chunk);

	return false;
};

MagicString.prototype.trimEnd = function trimEnd (charType) {
	this.trimEndAborted(charType);
	return this;
};
MagicString.prototype.trimStartAborted = function trimStartAborted (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');

	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var chunk = this.firstChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimStart(rx);

		if (chunk.end !== end) {
			// special case...
			if (chunk === this.lastChunk) { this.lastChunk = chunk.next; }

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.next;
	} while (chunk);

	return false;
};

MagicString.prototype.trimStart = function trimStart (charType) {
	this.trimStartAborted(charType);
	return this;
};

function parseAttributeValue(value) {
    return /^['"]/.test(value) ? value.slice(1, -1) : value;
}
function parseAttributes(str, start) {
    const attrs = [];
    str.split(/\s+/)
        .filter(Boolean)
        .forEach((attr) => {
        const attrStart = start + str.indexOf(attr);
        const [name, value] = attr.split('=');
        attrs[name] = value ? parseAttributeValue(value) : name;
        attrs.push({
            type: 'Attribute',
            name,
            value: !value || [
                {
                    type: 'Text',
                    start: attrStart + attr.indexOf('=') + 1,
                    end: attrStart + attr.length,
                    raw: parseAttributeValue(value)
                }
            ],
            start: attrStart,
            end: attrStart + attr.length
        });
    });
    return attrs;
}
function extractTag(htmlx, tag) {
    const exp = new RegExp(`(<!--[^]*?-->)|(<${tag}([\\S\\s]*?)>)([\\S\\s]*?)<\\/${tag}>`, 'g');
    const matches = [];
    let match = null;
    while ((match = exp.exec(htmlx)) != null) {
        if (match[0].startsWith('<!--')) {
            // Tag is inside comment
            continue;
        }
        const content = match[4];
        if (!content) {
            // Self-closing/empty tags don't need replacement
            continue;
        }
        const start = match.index + match[2].length;
        const end = start + content.length;
        const containerStart = match.index;
        const containerEnd = match.index + match[0].length;
        matches.push({
            start: containerStart,
            end: containerEnd,
            name: tag,
            type: tag === 'style' ? 'Style' : 'Script',
            attributes: parseAttributes(match[3], containerStart + `<${tag}`.length),
            content: {
                type: 'Text',
                start,
                end,
                value: content,
                raw: content
            }
        });
    }
    return matches;
}
function findVerbatimElements(htmlx) {
    return [...extractTag(htmlx, 'script'), ...extractTag(htmlx, 'style')];
}
function blankVerbatimContent(htmlx, verbatimElements) {
    let output = htmlx;
    for (const node of verbatimElements) {
        const content = node.content;
        if (content) {
            output =
                output.substring(0, content.start) +
                    output
                        .substring(content.start, content.end)
                        // blank out the content
                        .replace(/[^\n]/g, ' ')
                        // excess blank space can make the svelte parser very slow (sec->min). break it up with comments (works in style/script)
                        .replace(/[^\n][^\n][^\n][^\n]\n/g, '/**/\n') +
                    output.substring(content.end);
        }
    }
    return output;
}
function parseHtmlx(htmlx, options) {
    //Svelte tries to parse style and script tags which doesn't play well with typescript, so we blank them out.
    //HTMLx spec says they should just be retained after processing as is, so this is fine
    const verbatimElements = findVerbatimElements(htmlx);
    const deconstructed = blankVerbatimContent(htmlx, verbatimElements);
    //extract the html content parsed as htmlx this excludes our script and style tags
    const parsingCode = (options === null || options === void 0 ? void 0 : options.emitOnTemplateError)
        ? blankPossiblyErrorOperatorOrPropertyAccess(deconstructed)
        : deconstructed;
    const svelteHtmlxAst = compiler.parse(parsingCode).html;
    //restore our script and style tags as nodes to maintain validity with HTMLx
    for (const s of verbatimElements) {
        svelteHtmlxAst.children.push(s);
        svelteHtmlxAst.start = Math.min(svelteHtmlxAst.start, s.start);
        svelteHtmlxAst.end = Math.max(svelteHtmlxAst.end, s.end);
    }
    return svelteHtmlxAst;
}
const possibleOperatorOrPropertyAccess = new Set([
    '.',
    '?',
    '*',
    '~',
    '=',
    '<',
    '!',
    '&',
    '^',
    '|',
    ',',
    '+',
    '-'
]);
function blankPossiblyErrorOperatorOrPropertyAccess(htmlx) {
    let index = htmlx.indexOf('}');
    let lastIndex = 0;
    const { length } = htmlx;
    while (index < length && index >= 0) {
        let backwardIndex = index - 1;
        while (backwardIndex > lastIndex) {
            const char = htmlx.charAt(backwardIndex);
            if (possibleOperatorOrPropertyAccess.has(char)) {
                const isPlusOrMinus = char === '+' || char === '-';
                const isIncrementOrDecrement = isPlusOrMinus && htmlx.charAt(backwardIndex - 1) === char;
                if (isIncrementOrDecrement) {
                    backwardIndex -= 2;
                    continue;
                }
                htmlx =
                    htmlx.substring(0, backwardIndex) + ' ' + htmlx.substring(backwardIndex + 1);
            }
            else if (!/\s/.test(char)) {
                break;
            }
            backwardIndex--;
        }
        lastIndex = index;
        index = htmlx.indexOf('}', index + 1);
    }
    return htmlx;
}

function getTypeForComponent(node) {
    if (node.name === 'svelte:component' || node.name === 'svelte:self') {
        return '__sveltets_componentType()';
    }
    else {
        return node.name;
    }
}
function getThisType(node) {
    switch (node.type) {
        case 'InlineComponent':
            return getTypeForComponent(node);
        case 'Element':
            return `__sveltets_ctorOf(__sveltets_mapElementTag('${node.name}'))`;
        case 'Body':
            return 'HTMLBodyElement';
        case 'Slot': // Web Components only
            return 'HTMLSlotElement';
    }
}
function beforeStart(start) {
    return start - 1;
}
function isShortHandAttribute(attr) {
    return attr.expression.end === attr.end;
}
function isQuote(str) {
    return str === '"' || str === "'";
}

/**
 * use:xxx={params}   --->    {...__sveltets_ensureAction(xxx(__sveltets_mapElementTag('ParentNodeName'),(params)))}
 */
function handleActionDirective(htmlx, str, attr, parent) {
    str.overwrite(attr.start, attr.start + 'use:'.length, '{...__sveltets_ensureAction(');
    if (!attr.expression) {
        str.appendLeft(attr.end, `(__sveltets_mapElementTag('${parent.name}')))}`);
        return;
    }
    str.overwrite(attr.start + `use:${attr.name}`.length, attr.expression.start, `(__sveltets_mapElementTag('${parent.name}'),(`);
    str.appendLeft(attr.expression.end, ')))');
    const lastChar = htmlx[attr.end - 1];
    if (isQuote(lastChar)) {
        str.remove(attr.end - 1, attr.end);
    }
}

/**
 * animate:xxx(yyy)   --->   {...__sveltets_ensureAnimation(xxx(__sveltets_mapElementTag('..'),__sveltets_AnimationMove,(yyy)))}
 */
function handleAnimateDirective(htmlx, str, attr, parent) {
    str.overwrite(attr.start, htmlx.indexOf(':', attr.start) + 1, '{...__sveltets_ensureAnimation(');
    const nodeType = `__sveltets_mapElementTag('${parent.name}')`;
    if (!attr.expression) {
        str.appendLeft(attr.end, `(${nodeType},__sveltets_AnimationMove,{}))}`);
        return;
    }
    str.overwrite(htmlx.indexOf(':', attr.start) + 1 + `${attr.name}`.length, attr.expression.start, `(${nodeType},__sveltets_AnimationMove,(`);
    str.appendLeft(attr.expression.end, ')))');
    if (isQuote(htmlx[attr.end - 1])) {
        str.remove(attr.end - 1, attr.end);
    }
}

var svgAttributes = 'accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan'.split(' ');

/**
 * List taken from `svelte-jsx.d.ts` by searching for all attributes of type number
 */
const numberOnlyAttributes = new Set([
    'cols',
    'colspan',
    'currenttime',
    'defaultplaybackrate',
    'high',
    'low',
    'marginheight',
    'marginwidth',
    'minlength',
    'maxlength',
    'optimum',
    'rows',
    'rowspan',
    'size',
    'span',
    'start',
    'tabindex',
    'results',
    'volume'
]);
/**
 * Handle various kinds of attributes and make them conform to JSX.
 * - {x}   --->    x={x}
 * - x="{..}"   --->    x={..}
 * - lowercase DOM attributes
 * - multi-value handling
 */
function handleAttribute(htmlx, str, attr, parent) {
    let transformedFromDirectiveOrNamespace = false;
    //if we are on an "element" we are case insensitive, lowercase to match our JSX
    if (parent.type == 'Element') {
        const sapperLinkActions = ['sapper:prefetch', 'sapper:noscroll'];
        //skip Attribute shorthand, that is handled below
        if ((attr.value !== true &&
            !(attr.value.length &&
                attr.value.length == 1 &&
                attr.value[0].type == 'AttributeShorthand')) ||
            sapperLinkActions.includes(attr.name)) {
            let name = attr.name;
            if (!svgAttributes.find((x) => x == name)) {
                name = name.toLowerCase();
            }
            //strip ":" from out attribute name and uppercase the next letter to convert to jsx attribute
            const colonIndex = name.indexOf(':');
            if (colonIndex >= 0) {
                const parts = name.split(':');
                name = parts[0] + parts[1][0].toUpperCase() + parts[1].substring(1);
            }
            str.overwrite(attr.start, attr.start + attr.name.length, name);
            transformedFromDirectiveOrNamespace = true;
        }
    }
    //we are a bare attribute
    if (attr.value === true) {
        if (parent.type === 'Element' &&
            !transformedFromDirectiveOrNamespace &&
            parent.name !== '!DOCTYPE') {
            str.overwrite(attr.start, attr.end, attr.name.toLowerCase());
        }
        return;
    }
    if (attr.value.length == 0)
        return; //wut?
    //handle single value
    if (attr.value.length == 1) {
        const attrVal = attr.value[0];
        if (attr.name == 'slot') {
            str.remove(attr.start, attr.end);
            return;
        }
        if (attrVal.type == 'AttributeShorthand') {
            let attrName = attrVal.expression.name;
            if (parent.type == 'Element') {
                // eslint-disable-next-line max-len
                attrName = svgAttributes.find((a) => a == attrName)
                    ? attrName
                    : attrName.toLowerCase();
            }
            str.appendRight(attr.start, `${attrName}=`);
            return;
        }
        const equals = htmlx.lastIndexOf('=', attrVal.start);
        if (attrVal.type == 'Text') {
            const endsWithQuote = htmlx.lastIndexOf('"', attrVal.end) === attrVal.end - 1 ||
                htmlx.lastIndexOf("'", attrVal.end) === attrVal.end - 1;
            const needsQuotes = attrVal.end == attr.end && !endsWithQuote;
            const hasBrackets = htmlx.lastIndexOf('}', attrVal.end) === attrVal.end - 1 ||
                htmlx.lastIndexOf('}"', attrVal.end) === attrVal.end - 1 ||
                htmlx.lastIndexOf("}'", attrVal.end) === attrVal.end - 1;
            const needsNumberConversion = !hasBrackets &&
                parent.type === 'Element' &&
                numberOnlyAttributes.has(attr.name.toLowerCase()) &&
                !isNaN(attrVal.data);
            if (needsNumberConversion) {
                if (needsQuotes) {
                    str.prependRight(equals + 1, '{');
                    str.appendLeft(attr.end, '}');
                }
                else {
                    str.overwrite(equals + 1, equals + 2, '{');
                    str.overwrite(attr.end - 1, attr.end, '}');
                }
            }
            else if (needsQuotes) {
                str.prependRight(equals + 1, '"');
                str.appendLeft(attr.end, '"');
            }
            return;
        }
        if (attrVal.type == 'MustacheTag') {
            //if the end doesn't line up, we are wrapped in quotes
            if (attrVal.end != attr.end) {
                str.remove(attrVal.start - 1, attrVal.start);
                str.remove(attr.end - 1, attr.end);
            }
            return;
        }
        return;
    }
    // we have multiple attribute values, so we build a string out of them.
    // technically the user can do something funky like attr="text "{value} or even attr=text{value}
    // so instead of trying to maintain a nice sourcemap with prepends etc, we just overwrite the whole thing
    const equals = htmlx.lastIndexOf('=', attr.value[0].start);
    str.overwrite(equals, attr.value[0].start, '={`');
    for (const n of attr.value) {
        if (n.type == 'MustacheTag') {
            str.appendRight(n.start, '$');
        }
    }
    if (isQuote(htmlx[attr.end - 1])) {
        str.overwrite(attr.end - 1, attr.end, '`}');
    }
    else {
        str.appendLeft(attr.end, '`}');
    }
}

/**
 * Transform {#await ...} into something JSX understands
 */
function handleAwait(htmlx, str, awaitBlock) {
    // {#await somePromise then value} ->
    // {() => {let _$$p = (somePromise);
    str.overwrite(awaitBlock.start, awaitBlock.expression.start, '{() => {let _$$p = (');
    // then value } | {:then value} | {await ..} .. {/await} ->
    // __sveltets_awaitThen(_$$p, (value) => {<>
    let thenStart;
    let thenEnd;
    if (!awaitBlock.then.skip) {
        // then value } | {:then value}
        if (!awaitBlock.pending.skip) {
            // {await ...} ... {:then ...}
            // thenBlock includes the {:then}
            thenStart = awaitBlock.then.start;
            if (awaitBlock.value) {
                thenEnd = htmlx.indexOf('}', awaitBlock.value.end) + 1;
            }
            else {
                thenEnd = htmlx.indexOf('}', awaitBlock.then.start) + 1;
            }
            str.prependLeft(thenStart, '</>; ');
            // add the start tag too
            const awaitEnd = htmlx.indexOf('}', awaitBlock.expression.end);
            // somePromise} -> somePromise);
            str.overwrite(awaitBlock.expression.end, awaitEnd + 1, ');');
            str.appendRight(awaitEnd + 1, ' <>');
        }
        else {
            // {await ... then ...}
            thenStart = htmlx.indexOf('then', awaitBlock.expression.end);
            thenEnd = htmlx.lastIndexOf('}', awaitBlock.then.start) + 1;
            // somePromise then -> somePromise); then
            str.overwrite(awaitBlock.expression.end, thenStart, '); ');
        }
    }
    else {
        // {await ..} ... ({:catch ..}) {/await} -> no then block, no value, but always a pending block
        thenEnd = awaitBlock.catch.skip
            ? htmlx.lastIndexOf('{', awaitBlock.end)
            : awaitBlock.catch.start;
        thenStart = Math.min(awaitBlock.pending.end + 1, thenEnd);
        const awaitEnd = htmlx.indexOf('}', awaitBlock.expression.end);
        str.overwrite(awaitBlock.expression.end, awaitEnd + 1, ');');
        str.appendRight(awaitEnd + 1, ' <>');
        str.appendLeft(thenEnd, '</>; ');
    }
    if (awaitBlock.value) {
        str.overwrite(thenStart, awaitBlock.value.start, '__sveltets_awaitThen(_$$p, (');
        str.overwrite(awaitBlock.value.end, thenEnd, ') => {<>');
    }
    else {
        const awaitThenFn = '__sveltets_awaitThen(_$$p, () => {<>';
        if (thenStart === thenEnd) {
            str.appendLeft(thenStart, awaitThenFn);
        }
        else {
            str.overwrite(thenStart, thenEnd, awaitThenFn);
        }
    }
    //{:catch error} ->
    //</>}, (error) => {<>
    if (!awaitBlock.catch.skip) {
        //catch block includes the {:catch}
        const catchStart = awaitBlock.catch.start;
        const catchSymbolEnd = htmlx.indexOf(':catch', catchStart) + ':catch'.length;
        const errorStart = awaitBlock.error ? awaitBlock.error.start : catchSymbolEnd;
        const errorEnd = awaitBlock.error ? awaitBlock.error.end : errorStart;
        const catchEnd = htmlx.indexOf('}', errorEnd) + 1;
        str.overwrite(catchStart, errorStart, '</>}, (');
        str.overwrite(errorEnd, catchEnd, ') => {<>');
    }
    // {/await} ->
    // <>})}
    const awaitEndStart = htmlx.lastIndexOf('{', awaitBlock.end - 1);
    str.overwrite(awaitEndStart, awaitBlock.end, '</>})}}');
}

/**
 * {#key expr}content{/key}   --->   {expr} content
 */
function handleKey(htmlx, str, keyBlock) {
    // {#key expr}   ->   {expr}
    str.overwrite(keyBlock.start, keyBlock.expression.start, '{');
    const end = htmlx.indexOf('}', keyBlock.expression.end);
    str.overwrite(keyBlock.expression.end, end + 1, '} ');
    // {/key}   ->
    const endKey = htmlx.lastIndexOf('{', keyBlock.end - 1);
    str.remove(endKey, keyBlock.end);
}

const oneWayBindingAttributes = new Map(['clientWidth', 'clientHeight', 'offsetWidth', 'offsetHeight']
    .map((e) => [e, 'HTMLDivElement'])
    .concat(['duration', 'buffered', 'seekable', 'seeking', 'played', 'ended'].map((e) => [
    e,
    'HTMLMediaElement'
])));
/**
 * Transform bind:xxx into something that conforms to JSX
 */
function handleBinding(htmlx, str, attr, el) {
    //bind group on input
    if (attr.name == 'group' && el.name == 'input') {
        str.remove(attr.start, attr.expression.start);
        str.appendLeft(attr.expression.start, '{...__sveltets_empty(');
        const endBrackets = ')}';
        if (isShortHandAttribute(attr)) {
            str.prependRight(attr.end, endBrackets);
        }
        else {
            str.overwrite(attr.expression.end, attr.end, endBrackets);
        }
        return;
    }
    const supportsBindThis = [
        'InlineComponent',
        'Element',
        'Body',
        'Slot' // only valid for Web Components compile target
    ];
    //bind this
    if (attr.name === 'this' && supportsBindThis.includes(el.type)) {
        const thisType = getThisType(el);
        if (thisType) {
            str.remove(attr.start, attr.expression.start);
            str.appendLeft(attr.expression.start, `{...__sveltets_ensureType(${thisType}, `);
            str.overwrite(attr.expression.end, attr.end, ')}');
            return;
        }
    }
    //one way binding
    if (oneWayBindingAttributes.has(attr.name) && el.type === 'Element') {
        str.remove(attr.start, attr.expression.start);
        str.appendLeft(attr.expression.start, '{...__sveltets_empty(');
        if (isShortHandAttribute(attr)) {
            // eslint-disable-next-line max-len
            str.appendLeft(attr.end, `=__sveltets_instanceOf(${oneWayBindingAttributes.get(attr.name)}).${attr.name})}`);
        }
        else {
            // eslint-disable-next-line max-len
            str.overwrite(attr.expression.end, attr.end, `=__sveltets_instanceOf(${oneWayBindingAttributes.get(attr.name)}).${attr.name})}`);
        }
        return;
    }
    str.remove(attr.start, attr.start + 'bind:'.length);
    if (attr.expression.start === attr.start + 'bind:'.length) {
        str.prependLeft(attr.expression.start, `${attr.name}={`);
        str.appendLeft(attr.end, '}');
        return;
    }
    //remove possible quotes
    const lastChar = htmlx[attr.end - 1];
    if (isQuote(lastChar)) {
        const firstQuote = htmlx.indexOf(lastChar, attr.start);
        str.remove(firstQuote, firstQuote + 1);
        str.remove(attr.end - 1, attr.end);
    }
}

/**
 * class:xx={yyy}   --->   {...__sveltets_ensureType(Boolean, !!(yyy))}
 */
function handleClassDirective(str, attr) {
    str.overwrite(attr.start, attr.expression.start, '{...__sveltets_ensureType(Boolean, !!(');
    const endBrackets = '))}';
    if (attr.end !== attr.expression.end) {
        str.overwrite(attr.expression.end, attr.end, endBrackets);
    }
    else {
        str.appendLeft(attr.end, endBrackets);
    }
}

/**
 * Removes comment
 */
function handleComment(str, node) {
    str.remove(node.start, node.end);
}

function isMember(parent, prop) {
    return parent.type == 'MemberExpression' && prop == 'property';
}
function isObjectKey(parent, prop) {
    return parent.type == 'Property' && prop == 'key';
}
function isObjectValue(parent, prop) {
    return parent.type == 'Property' && prop == 'value';
}
function isObjectValueShortHand(property) {
    const { value, key } = property;
    return value && isIdentifier(value) && key.start === value.start && key.end == value.end;
}
function attributeValueIsString(attr) {
    var _a;
    return attr.value.length !== 1 || ((_a = attr.value[0]) === null || _a === void 0 ? void 0 : _a.type) === 'Text';
}
function isDestructuringPatterns(node) {
    return node.type === 'ArrayPattern' || node.type === 'ObjectPattern';
}
function isIdentifier(node) {
    return node.type === 'Identifier';
}
function getSlotName(child) {
    var _a, _b;
    const slot = (_a = child.attributes) === null || _a === void 0 ? void 0 : _a.find((a) => a.name == 'slot');
    return (_b = slot === null || slot === void 0 ? void 0 : slot.value) === null || _b === void 0 ? void 0 : _b[0].raw;
}

// @ts-check
/** @typedef { import('estree').BaseNode} BaseNode */

/** @typedef {{
	skip: () => void;
	remove: () => void;
	replace: (node: BaseNode) => void;
}} WalkerContext */

class WalkerBase {
	constructor() {
		/** @type {boolean} */
		this.should_skip = false;

		/** @type {boolean} */
		this.should_remove = false;

		/** @type {BaseNode | null} */
		this.replacement = null;

		/** @type {WalkerContext} */
		this.context = {
			skip: () => (this.should_skip = true),
			remove: () => (this.should_remove = true),
			replace: (node) => (this.replacement = node)
		};
	}

	/**
	 *
	 * @param {any} parent
	 * @param {string} prop
	 * @param {number} index
	 * @param {BaseNode} node
	 */
	replace(parent, prop, index, node) {
		if (parent) {
			if (index !== null) {
				parent[prop][index] = node;
			} else {
				parent[prop] = node;
			}
		}
	}

	/**
	 *
	 * @param {any} parent
	 * @param {string} prop
	 * @param {number} index
	 */
	remove(parent, prop, index) {
		if (parent) {
			if (index !== null) {
				parent[prop].splice(index, 1);
			} else {
				delete parent[prop];
			}
		}
	}
}

// @ts-check

/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef { import('./walker.js').WalkerContext} WalkerContext */

/** @typedef {(
 *    this: WalkerContext,
 *    node: BaseNode,
 *    parent: BaseNode,
 *    key: string,
 *    index: number
 * ) => void} SyncHandler */

class SyncWalker extends WalkerBase {
	/**
	 *
	 * @param {SyncHandler} enter
	 * @param {SyncHandler} leave
	 */
	constructor(enter, leave) {
		super();

		/** @type {SyncHandler} */
		this.enter = enter;

		/** @type {SyncHandler} */
		this.leave = leave;
	}

	/**
	 *
	 * @param {BaseNode} node
	 * @param {BaseNode} parent
	 * @param {string} [prop]
	 * @param {number} [index]
	 * @returns {BaseNode}
	 */
	visit(node, parent, prop, index) {
		if (node) {
			if (this.enter) {
				const _should_skip = this.should_skip;
				const _should_remove = this.should_remove;
				const _replacement = this.replacement;
				this.should_skip = false;
				this.should_remove = false;
				this.replacement = null;

				this.enter.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const skipped = this.should_skip;
				const removed = this.should_remove;

				this.should_skip = _should_skip;
				this.should_remove = _should_remove;
				this.replacement = _replacement;

				if (skipped) return node;
				if (removed) return null;
			}

			for (const key in node) {
				const value = node[key];

				if (typeof value !== "object") {
					continue;
				} else if (Array.isArray(value)) {
					for (let i = 0; i < value.length; i += 1) {
						if (value[i] !== null && typeof value[i].type === 'string') {
							if (!this.visit(value[i], node, key, i)) {
								// removed
								i--;
							}
						}
					}
				} else if (value !== null && typeof value.type === "string") {
					this.visit(value, node, key, null);
				}
			}

			if (this.leave) {
				const _replacement = this.replacement;
				const _should_remove = this.should_remove;
				this.replacement = null;
				this.should_remove = false;

				this.leave.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const removed = this.should_remove;

				this.replacement = _replacement;
				this.should_remove = _should_remove;

				if (removed) return null;
			}
		}

		return node;
	}
}

// @ts-check

/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef { import('./sync.js').SyncHandler} SyncHandler */
/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */

/**
 *
 * @param {BaseNode} ast
 * @param {{
 *   enter?: SyncHandler
 *   leave?: SyncHandler
 * }} walker
 * @returns {BaseNode}
 */
function walk(ast, { enter, leave }) {
	const instance = new SyncWalker(enter, leave);
	return instance.visit(ast, null);
}

function attributeStrValueAsJsExpression(attr) {
    if (attr.value.length == 0)
        return "''"; //wut?
    //handle single value
    if (attr.value.length == 1) {
        const attrVal = attr.value[0];
        if (attrVal.type == 'Text') {
            return '"' + attrVal.raw + '"';
        }
    }
    // we have multiple attribute values, so we know we are building a string out of them.
    // so return a dummy string, it will typecheck the same :)
    return '"__svelte_ts_string"';
}
class SlotHandler {
    constructor(htmlx) {
        this.htmlx = htmlx;
        this.slots = new Map();
        this.resolved = new Map();
        this.resolvedExpression = new Map();
    }
    resolve(identifierDef, initExpression, scope) {
        let resolved = this.resolved.get(identifierDef);
        if (resolved) {
            return resolved;
        }
        resolved = this.getResolveExpressionStr(identifierDef, scope, initExpression);
        if (resolved) {
            this.resolved.set(identifierDef, resolved);
        }
        return resolved;
    }
    getResolveExpressionStr(identifierDef, scope, initExpression) {
        const { name } = identifierDef;
        const owner = scope.getOwner(name);
        if ((owner === null || owner === void 0 ? void 0 : owner.type) === 'CatchBlock') {
            return '__sveltets_any({})';
        }
        // list.map(list => list.someProperty)
        // initExpression's scope should the parent scope of identifier scope
        else if ((owner === null || owner === void 0 ? void 0 : owner.type) === 'ThenBlock') {
            const resolvedExpression = this.resolveExpression(initExpression, scope.parent);
            return `__sveltets_unwrapPromiseLike(${resolvedExpression})`;
        }
        else if ((owner === null || owner === void 0 ? void 0 : owner.type) === 'EachBlock') {
            const resolvedExpression = this.resolveExpression(initExpression, scope.parent);
            return `__sveltets_unwrapArr(${resolvedExpression})`;
        }
        return null;
    }
    resolveDestructuringAssignment(destructuringNode, identifiers, initExpression, scope) {
        const destructuring = this.htmlx.slice(destructuringNode.start, destructuringNode.end);
        identifiers.forEach((identifier) => {
            const resolved = this.getResolveExpressionStr(identifier, scope, initExpression);
            if (resolved) {
                this.resolved.set(identifier, `((${destructuring}) => ${identifier.name})(${resolved})`);
            }
        });
    }
    resolveDestructuringAssignmentForLet(destructuringNode, identifiers, letNode, component, slotName) {
        const destructuring = this.htmlx.slice(destructuringNode.start, destructuringNode.end);
        identifiers.forEach((identifier) => {
            const resolved = this.getResolveExpressionStrForLet(letNode, component, slotName);
            this.resolved.set(identifier, `((${destructuring}) => ${identifier.name})(${resolved})`);
        });
    }
    getResolveExpressionStrForLet(letNode, component, slotName) {
        return `${getSingleSlotDef(component, slotName)}.${letNode.name}`;
    }
    resolveLet(letNode, identifierDef, component, slotName) {
        let resolved = this.resolved.get(identifierDef);
        if (resolved) {
            return resolved;
        }
        resolved = this.getResolveExpressionStrForLet(letNode, component, slotName);
        this.resolved.set(identifierDef, resolved);
        return resolved;
    }
    getSlotConsumerOfComponent(component) {
        var _a;
        let result = (_a = this.getLetNodes(component, 'default')) !== null && _a !== void 0 ? _a : [];
        for (const child of component.children) {
            const slotName = getSlotName(child);
            if (slotName) {
                const letNodes = this.getLetNodes(child, slotName);
                if (letNodes === null || letNodes === void 0 ? void 0 : letNodes.length) {
                    result = result.concat(letNodes);
                }
            }
        }
        return result;
    }
    getLetNodes(child, slotName) {
        var _a;
        const letNodes = ((_a = child === null || child === void 0 ? void 0 : child.attributes) !== null && _a !== void 0 ? _a : []).filter((attr) => attr.type === 'Let');
        return letNodes === null || letNodes === void 0 ? void 0 : letNodes.map((letNode) => ({
            letNode,
            slotName
        }));
    }
    resolveExpression(expression, scope) {
        let resolved = this.resolvedExpression.get(expression);
        if (resolved) {
            return resolved;
        }
        const strForExpression = new MagicString(this.htmlx);
        const identifiers = [];
        const objectShortHands = [];
        walk(expression, {
            enter(node, parent, prop) {
                if (node.type === 'Identifier') {
                    if (parent) {
                        if (isMember(parent, prop))
                            return;
                        if (isObjectKey(parent, prop)) {
                            return;
                        }
                        if (isObjectValue(parent, prop)) {
                            // { value }
                            if (isObjectValueShortHand(parent)) {
                                this.skip();
                                objectShortHands.push(node);
                                return;
                            }
                        }
                    }
                    this.skip();
                    identifiers.push(node);
                }
            }
        });
        const getOverwrite = (name) => {
            const init = scope.getInit(name);
            return init ? this.resolved.get(init) : name;
        };
        for (const identifier of objectShortHands) {
            const { end, name } = identifier;
            const value = getOverwrite(name);
            strForExpression.appendLeft(end, `:${value}`);
        }
        for (const identifier of identifiers) {
            const { start, end, name } = identifier;
            const value = getOverwrite(name);
            strForExpression.overwrite(start, end, value);
        }
        resolved = strForExpression.slice(expression.start, expression.end);
        this.resolvedExpression.set(expression, resolved);
        return resolved;
    }
    handleSlot(node, scope) {
        var _a;
        const nameAttr = node.attributes.find((a) => a.name == 'name');
        const slotName = nameAttr ? nameAttr.value[0].raw : 'default';
        //collect attributes
        const attributes = new Map();
        for (const attr of node.attributes) {
            if (attr.name == 'name')
                continue;
            if (!((_a = attr.value) === null || _a === void 0 ? void 0 : _a.length))
                continue;
            if (attributeValueIsString(attr)) {
                attributes.set(attr.name, attributeStrValueAsJsExpression(attr));
                continue;
            }
            attributes.set(attr.name, this.resolveAttr(attr, scope));
        }
        this.slots.set(slotName, attributes);
    }
    getSlotDef() {
        return this.slots;
    }
    resolveAttr(attr, scope) {
        const attrVal = attr.value[0];
        if (!attrVal) {
            return null;
        }
        if (attrVal.type == 'AttributeShorthand') {
            const { name } = attrVal.expression;
            const init = scope.getInit(name);
            const resolved = this.resolved.get(init);
            return resolved !== null && resolved !== void 0 ? resolved : name;
        }
        if (attrVal.type == 'MustacheTag') {
            return this.resolveExpression(attrVal.expression, scope);
        }
        throw Error('Unknown attribute value type:' + attrVal.type);
    }
}
function getSingleSlotDef(componentNode, slotName) {
    const componentType = getTypeForComponent(componentNode);
    return `__sveltets_instanceOf(${componentType}).$$slot_def['${slotName}']`;
}

/**
 * Handle `<svelte:self>` and slot-specific transformations.
 */
function handleComponent(htmlx, str, el) {
    //we need to remove : if it is a svelte component
    if (el.name.startsWith('svelte:')) {
        const colon = htmlx.indexOf(':', el.start);
        str.remove(colon, colon + 1);
        const closeTag = htmlx.lastIndexOf('/' + el.name, el.end);
        if (closeTag > el.start) {
            const colon = htmlx.indexOf(':', closeTag);
            str.remove(colon, colon + 1);
        }
    }
    //we only need to do something if there is a let or slot
    handleSlot(htmlx, str, el, el, 'default');
    //walk the direct children looking for slots. We do this here because we need the name of our component for handleSlot
    //we could lean on leave/enter, but I am lazy
    if (!el.children)
        return;
    for (const child of el.children) {
        const slotName = getSlotName(child);
        if (slotName) {
            handleSlot(htmlx, str, child, el, slotName);
        }
    }
}
function handleSlot(htmlx, str, slotEl, component, slotName) {
    //collect "let" definitions
    const slotElIsComponent = slotEl === component;
    let hasMoved = false;
    let slotDefInsertionPoint;
    for (const attr of slotEl.attributes) {
        if (attr.type != 'Let') {
            continue;
        }
        if (slotElIsComponent && slotEl.children.length == 0) {
            //no children anyway, just wipe out the attribute
            str.remove(attr.start, attr.end);
            continue;
        }
        slotDefInsertionPoint =
            slotDefInsertionPoint ||
                (slotElIsComponent
                    ? htmlx.lastIndexOf('>', slotEl.children[0].start) + 1
                    : slotEl.start);
        str.move(attr.start, attr.end, slotDefInsertionPoint);
        //remove let:
        if (hasMoved) {
            str.overwrite(attr.start, attr.start + 'let:'.length, ', ');
        }
        else {
            str.remove(attr.start, attr.start + 'let:'.length);
        }
        hasMoved = true;
        if (attr.expression) {
            //overwrite the = as a :
            const equalSign = htmlx.lastIndexOf('=', attr.expression.start);
            const curly = htmlx.lastIndexOf('{', beforeStart(attr.expression.start));
            str.overwrite(equalSign, curly + 1, ':');
            str.remove(attr.expression.end, attr.end);
        }
    }
    if (!hasMoved) {
        return;
    }
    str.appendLeft(slotDefInsertionPoint, '{() => { let {');
    str.appendRight(slotDefInsertionPoint, `} = ${getSingleSlotDef(component, slotName)}` + ';<>');
    const closeSlotDefInsertionPoint = slotElIsComponent
        ? htmlx.lastIndexOf('<', slotEl.end - 1)
        : slotEl.end;
    str.appendLeft(closeSlotDefInsertionPoint, '</>}}');
}

/**
 * {@debug a}		--->   {a}
 * {@debug a, b}	--->   {a}{b}
 * tsx won't accept commas, must split
 */
function handleDebug(_htmlx, str, debugBlock) {
    let cursor = debugBlock.start;
    for (const identifier of debugBlock.identifiers) {
        str.remove(cursor, identifier.start);
        str.prependLeft(identifier.start, '{');
        str.prependLeft(identifier.end, '}');
        cursor = identifier.end;
    }
    str.remove(cursor, debugBlock.end);
}

/**
 * Transform each block into something JSX can understand.
 */
function handleEach(htmlx, str, eachBlock) {
    // {#each items as item,i (key)} ->
    // {__sveltets_each(items, (item,i) => (key) && <>
    str.overwrite(eachBlock.start, eachBlock.expression.start, '{__sveltets_each(');
    str.overwrite(eachBlock.expression.end, eachBlock.context.start, ', (');
    // {#each true, items as item}
    if (eachBlock.expression.type === 'SequenceExpression') {
        str.appendRight(eachBlock.expression.start, '(');
        str.appendLeft(eachBlock.expression.end, ')');
    }
    let contextEnd = eachBlock.context.end;
    if (eachBlock.index) {
        const idxLoc = htmlx.indexOf(eachBlock.index, contextEnd);
        contextEnd = idxLoc + eachBlock.index.length;
    }
    str.prependLeft(contextEnd, ') =>');
    if (eachBlock.key) {
        const endEachStart = htmlx.indexOf('}', eachBlock.key.end);
        str.overwrite(endEachStart, endEachStart + 1, ' && <>');
    }
    else {
        const endEachStart = htmlx.indexOf('}', contextEnd);
        str.overwrite(endEachStart, endEachStart + 1, ' <>');
    }
    const endEach = htmlx.lastIndexOf('{', eachBlock.end - 1);
    // {/each} -> </>)} or {:else} -> </>)}
    if (eachBlock.else) {
        const elseEnd = htmlx.lastIndexOf('}', eachBlock.else.start);
        const elseStart = htmlx.lastIndexOf('{', elseEnd);
        str.overwrite(elseStart, elseEnd + 1, '</>)}');
        str.remove(endEach, eachBlock.end);
    }
    else {
        str.overwrite(endEach, eachBlock.end, '</>)}');
    }
}

/**
 * Special treatment for self-closing / void tags to make them conform to JSX.
 */
function handleElement(htmlx, str, node) {
    //we just have to self close void tags since jsx always wants the />
    const voidTags = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'.split(',');
    if (voidTags.find((x) => x == node.name)) {
        if (htmlx[node.end - 2] != '/') {
            str.appendRight(node.end - 1, '/');
        }
    }
    //some tags auto close when they encounter certain elements, jsx doesn't support this
    if (htmlx[node.end - 1] != '>') {
        str.appendRight(node.end, `</${node.name}>`);
    }
}

/**
 * Transform on:xxx={yyy}
 * - For DOM elements: ---> onxxx={yyy}
 * - For Svelte components/special elements: ---> {__sveltets_instanceOf(..ComponentType..).$on("xxx", yyy)}
 */
function handleEventHandler(htmlx, str, attr, parent) {
    const jsxEventName = attr.name;
    if (['Element', 'Window', 'Body'].includes(parent.type) /*&& KnownEvents.indexOf('on'+jsxEventName) >= 0*/) {
        if (attr.expression) {
            const endAttr = htmlx.indexOf('=', attr.start);
            str.overwrite(attr.start + 'on:'.length - 1, endAttr, jsxEventName);
            const lastChar = htmlx[attr.end - 1];
            if (isQuote(lastChar)) {
                const firstQuote = htmlx.indexOf(lastChar, endAttr);
                str.remove(firstQuote, firstQuote + 1);
                str.remove(attr.end - 1, attr.end);
            }
        }
        else {
            str.overwrite(attr.start + 'on:'.length - 1, attr.end, `${jsxEventName}={undefined}`);
        }
    }
    else {
        if (attr.expression) {
            const on = 'on';
            //for handler assignment, we change it to call to our __sveltets_ensureFunction
            str.appendRight(attr.start, `{__sveltets_instanceOf(${getTypeForComponent(parent)}).$`);
            const eventNameIndex = htmlx.indexOf(':', attr.start) + 1;
            str.overwrite(htmlx.indexOf(on, attr.start) + on.length, eventNameIndex, "('");
            const eventEnd = htmlx.lastIndexOf('=', attr.expression.start);
            str.overwrite(eventEnd, attr.expression.start, "', ");
            str.overwrite(attr.expression.end, attr.end, ')}');
            str.move(attr.start, attr.end, parent.end);
        }
        else {
            //for passthrough handlers, we just remove
            str.remove(attr.start, attr.end);
        }
    }
}

/**
 * {# if ...}...{/if}   --->   {() => {if(...){<>...</>}}}
 */
function handleIf(htmlx, str, ifBlock) {
    const endIf = htmlx.lastIndexOf('{', ifBlock.end - 1);
    if (ifBlock.elseif) {
        // {:else if expr}  ->  : (expr) ? <>
        const elseIfStart = htmlx.lastIndexOf('{', ifBlock.expression.start);
        const elseIfConditionEnd = htmlx.indexOf('}', ifBlock.expression.end) + 1;
        str.overwrite(elseIfStart, ifBlock.expression.start, '</> : (', { contentOnly: true });
        str.overwrite(ifBlock.expression.end, elseIfConditionEnd, ') ? <>');
        if (!ifBlock.else) {
            str.appendLeft(endIf, '</> : <>');
        }
        return;
    }
    // {#if expr}  ->  {(expr) ? <>
    str.overwrite(ifBlock.start, ifBlock.expression.start, '{(', { contentOnly: true });
    const end = htmlx.indexOf('}', ifBlock.expression.end);
    str.overwrite(ifBlock.expression.end, end + 1, ') ? <>', { contentOnly: true });
    if (ifBlock.else) {
        // {/if}  ->  </> }
        str.overwrite(endIf, ifBlock.end, '</> }', { contentOnly: true });
    }
    else {
        // {/if}  ->  </> : <></>}
        str.overwrite(endIf, ifBlock.end, '</> : <></>}', { contentOnly: true });
    }
}
/**
 * {:else}   --->   </> : <>
 */
function handleElse(htmlx, str, elseBlock, parent) {
    var _a, _b;
    if (parent.type !== 'IfBlock' ||
        (((_a = elseBlock.children[0]) === null || _a === void 0 ? void 0 : _a.type) === 'IfBlock' && ((_b = elseBlock.children[0]) === null || _b === void 0 ? void 0 : _b.elseif))) {
        return;
    }
    const elseEnd = htmlx.lastIndexOf('}', elseBlock.start);
    const elseword = htmlx.lastIndexOf(':else', elseEnd);
    const elseStart = htmlx.lastIndexOf('{', elseword);
    str.overwrite(elseStart, elseEnd + 1, '</> : <>');
}

/**
 * {@html ...}   --->   {...}
 */
function handleRawHtml(htmlx, str, rawBlock) {
    const tokenStart = htmlx.indexOf('@html', rawBlock.start);
    str.remove(tokenStart, tokenStart + '@html'.length);
}

/**
 * `<svelte:window>...</svelte:window>`   ---->    `<sveltewindow>...</sveltewindow>`
 * (same for :head, :body, :options)
 */
function handleSvelteTag(htmlx, str, node) {
    const colon = htmlx.indexOf(':', node.start);
    str.remove(colon, colon + 1);
    const closeTag = htmlx.lastIndexOf('/' + node.name, node.end);
    if (closeTag > node.start) {
        const colon = htmlx.indexOf(':', closeTag);
        str.remove(colon, colon + 1);
    }
}

/**
 * transition:xxx(yyy)   --->   {...__sveltets_ensureTransition(xxx(__sveltets_mapElementTag('..'),(yyy)))}
 */
function handleTransitionDirective(htmlx, str, attr, parent) {
    str.overwrite(attr.start, htmlx.indexOf(':', attr.start) + 1, '{...__sveltets_ensureTransition(');
    if (attr.modifiers.length) {
        const local = htmlx.indexOf('|', attr.start);
        str.remove(local, attr.expression ? attr.expression.start : attr.end);
    }
    const nodeType = `__sveltets_mapElementTag('${parent.name}')`;
    if (!attr.expression) {
        str.appendLeft(attr.end, `(${nodeType},{}))}`);
        return;
    }
    str.overwrite(htmlx.indexOf(':', attr.start) + 1 + `${attr.name}`.length, attr.expression.start, `(${nodeType},(`);
    str.appendLeft(attr.expression.end, ')))');
    if (isQuote(htmlx[attr.end - 1])) {
        str.remove(attr.end - 1, attr.end);
    }
}

function handleText(str, node) {
    if (!node.data) {
        return;
    }
    const needsRemoves = ['}', '>'];
    for (const token of needsRemoves) {
        let index = node.data.indexOf(token);
        while (index >= 0) {
            str.remove(index + node.start, index + node.start + 1);
            index = node.data.indexOf(token, index + 1);
        }
    }
}

function stripDoctype(str) {
    const regex = /<!doctype(.+?)>(\n)?/i;
    const result = regex.exec(str.original);
    if (result) {
        str.remove(result.index, result.index + result[0].length);
    }
}
/**
 * Walks the HTMLx part of the Svelte component
 * and converts it to JSX
 */
function convertHtmlxToJsx(str, ast, onWalk = null, onLeave = null) {
    const htmlx = str.original;
    stripDoctype(str);
    str.prepend('<>');
    str.append('</>');
    compiler.walk(ast, {
        enter: (node, parent, prop, index) => {
            try {
                switch (node.type) {
                    case 'IfBlock':
                        handleIf(htmlx, str, node);
                        break;
                    case 'EachBlock':
                        handleEach(htmlx, str, node);
                        break;
                    case 'ElseBlock':
                        handleElse(htmlx, str, node, parent);
                        break;
                    case 'AwaitBlock':
                        handleAwait(htmlx, str, node);
                        break;
                    case 'KeyBlock':
                        handleKey(htmlx, str, node);
                        break;
                    case 'RawMustacheTag':
                        handleRawHtml(htmlx, str, node);
                        break;
                    case 'DebugTag':
                        handleDebug(htmlx, str, node);
                        break;
                    case 'InlineComponent':
                        handleComponent(htmlx, str, node);
                        break;
                    case 'Element':
                        handleElement(htmlx, str, node);
                        break;
                    case 'Comment':
                        handleComment(str, node);
                        break;
                    case 'Binding':
                        handleBinding(htmlx, str, node, parent);
                        break;
                    case 'Class':
                        handleClassDirective(str, node);
                        break;
                    case 'Action':
                        handleActionDirective(htmlx, str, node, parent);
                        break;
                    case 'Transition':
                        handleTransitionDirective(htmlx, str, node, parent);
                        break;
                    case 'Animation':
                        handleAnimateDirective(htmlx, str, node, parent);
                        break;
                    case 'Attribute':
                        handleAttribute(htmlx, str, node, parent);
                        break;
                    case 'EventHandler':
                        handleEventHandler(htmlx, str, node, parent);
                        break;
                    case 'Options':
                        handleSvelteTag(htmlx, str, node);
                        break;
                    case 'Window':
                        handleSvelteTag(htmlx, str, node);
                        break;
                    case 'Head':
                        handleSvelteTag(htmlx, str, node);
                        break;
                    case 'Body':
                        handleSvelteTag(htmlx, str, node);
                        break;
                    case 'Text':
                        handleText(str, node);
                        break;
                }
                if (onWalk) {
                    onWalk(node, parent, prop, index);
                }
            }
            catch (e) {
                console.error('Error walking node ', node);
                throw e;
            }
        },
        leave: (node, parent, prop, index) => {
            try {
                if (onLeave) {
                    onLeave(node, parent, prop, index);
                }
            }
            catch (e) {
                console.error('Error leaving node ', node);
                throw e;
            }
        }
    });
}

/**
 * Add this tag to a HTML comment in a Svelte component and its contents will
 * be added as a docstring in the resulting JSX for the component class.
 */
const COMPONENT_DOCUMENTATION_HTML_COMMENT_TAG = '@component';
class ComponentDocumentation {
    constructor() {
        this.componentDocumentation = '';
        this.handleComment = (node) => {
            if ('data' in node &&
                typeof node.data === 'string' &&
                node.data.includes(COMPONENT_DOCUMENTATION_HTML_COMMENT_TAG)) {
                this.componentDocumentation = node.data
                    .replace(COMPONENT_DOCUMENTATION_HTML_COMMENT_TAG, '')
                    .trim();
            }
        };
    }
    getFormatted() {
        if (!this.componentDocumentation) {
            return '';
        }
        if (!this.componentDocumentation.includes('\n')) {
            return `/** ${this.componentDocumentation} */\n`;
        }
        const lines = dedent(this.componentDocumentation)
            .split('\n')
            .map((line) => ` *${line ? ` ${line}` : ''}`)
            .join('\n');
        return `/**\n${lines}\n */\n`;
    }
}

function findExportKeyword(node) {
    var _a;
    return (_a = node.modifiers) === null || _a === void 0 ? void 0 : _a.find((x) => x.kind == ts__default.SyntaxKind.ExportKeyword);
}
/**
 * Node is like `bla = ...` or `{bla} = ...` or `[bla] = ...`
 */
function isAssignmentBinaryExpr(node) {
    return (ts__default.isBinaryExpression(node) &&
        node.operatorToken.kind == ts__default.SyntaxKind.EqualsToken &&
        (ts__default.isIdentifier(node.left) ||
            ts__default.isObjectLiteralExpression(node.left) ||
            ts__default.isArrayLiteralExpression(node.left)));
}
/**
 * Returns if node is like `$: bla = ...` or `$: ({bla} = ...)` or `$: [bla] = ...=`
 */
function getBinaryAssignmentExpr(node) {
    if (ts__default.isExpressionStatement(node.statement)) {
        if (isAssignmentBinaryExpr(node.statement.expression)) {
            return node.statement.expression;
        }
        if (ts__default.isParenthesizedExpression(node.statement.expression) &&
            isAssignmentBinaryExpr(node.statement.expression.expression)) {
            return node.statement.expression.expression;
        }
    }
}
/**
 * Returns true if node is like `({bla} ..)` or `([bla] ...)`
 */
function isParenthesizedObjectOrArrayLiteralExpression(node) {
    return (ts__default.isParenthesizedExpression(node) &&
        ts__default.isBinaryExpression(node.expression) &&
        (ts__default.isObjectLiteralExpression(node.expression.left) ||
            ts__default.isArrayLiteralExpression(node.expression.left)));
}
/**
 *
 * Adapted from https://github.com/Rich-Harris/periscopic/blob/d7a820b04e1f88b452313ab3e54771b352f0defb/src/index.ts#L150
 */
function extractIdentifiers(node, identifiers = []) {
    if (ts__default.isIdentifier(node)) {
        identifiers.push(node);
    }
    else if (ts__default.isBindingElement(node)) {
        extractIdentifiers(node.name, identifiers);
    }
    else if (isMember$1(node)) {
        let object = node;
        while (isMember$1(object)) {
            object = object.expression;
        }
        if (ts__default.isIdentifier(object)) {
            identifiers.push(object);
        }
    }
    else if (ts__default.isArrayBindingPattern(node) || ts__default.isObjectBindingPattern(node)) {
        node.elements.forEach((element) => {
            extractIdentifiers(element, identifiers);
        });
    }
    else if (ts__default.isObjectLiteralExpression(node)) {
        node.properties.forEach((child) => {
            if (ts__default.isSpreadAssignment(child)) {
                extractIdentifiers(child.expression, identifiers);
            }
            else if (ts__default.isShorthandPropertyAssignment(child)) {
                // in ts Ast { a = 1 } and { a } are both ShorthandPropertyAssignment
                extractIdentifiers(child.name, identifiers);
            }
        });
    }
    else if (ts__default.isArrayLiteralExpression(node)) {
        node.elements.forEach((element) => {
            if (ts__default.isSpreadElement(element)) {
                extractIdentifiers(element, identifiers);
            }
            else {
                extractIdentifiers(element, identifiers);
            }
        });
    }
    return identifiers;
}
function isMember$1(node) {
    return ts__default.isElementAccessExpression(node) || ts__default.isPropertyAccessExpression(node);
}
/**
 * Returns variable at given level with given name,
 * if it is a variable declaration in the form of `const/let a = ..`
 */
function getVariableAtTopLevel(node, identifierName) {
    for (const child of node.statements) {
        if (ts__default.isVariableStatement(child)) {
            const variable = child.declarationList.declarations.find((declaration) => ts__default.isIdentifier(declaration.name) && declaration.name.text === identifierName);
            if (variable) {
                return variable;
            }
        }
    }
}
/**
 * Get the leading multiline trivia doc of the node.
 */
function getLastLeadingDoc(node) {
    var _a;
    const nodeText = node.getFullText();
    const comments = (_a = ts__default
        .getLeadingCommentRanges(nodeText, 0)) === null || _a === void 0 ? void 0 : _a.filter((c) => c.kind === ts__default.SyntaxKind.MultiLineCommentTrivia);
    const comment = comments === null || comments === void 0 ? void 0 : comments[(comments === null || comments === void 0 ? void 0 : comments.length) - 1];
    if (comment) {
        let commentText = nodeText.substring(comment.pos, comment.end);
        const typedefTags = ts__default.getAllJSDocTagsOfKind(node, ts__default.SyntaxKind.JSDocTypedefTag);
        typedefTags
            .filter((tag) => tag.pos >= comment.pos)
            .map((tag) => nodeText.substring(tag.pos, tag.end))
            .forEach((comment) => {
            commentText = commentText.replace(comment, '');
        });
        return commentText;
    }
}
/**
 * Returns true if given identifier is not the property name of an aliased import.
 * In other words: It is not `a` in `import {a as b} from ..`
 */
function isNotPropertyNameOfImport(identifier) {
    return (!ts__default.isImportSpecifier(identifier.parent) || identifier.parent.propertyName !== identifier);
}
/**
 * Extract the variable names that are assigned to out of a labeled statement.
 */
function getNamesFromLabeledStatement(node) {
    var _a;
    const leftHandSide = (_a = getBinaryAssignmentExpr(node)) === null || _a === void 0 ? void 0 : _a.left;
    if (!leftHandSide) {
        return [];
    }
    return (extractIdentifiers(leftHandSide)
        .map((id) => id.text)
        // svelte won't let you create a variable with $ prefix (reserved for stores)
        .filter((name) => !name.startsWith('$')));
}

/**
 * This class accumulates all events that are dispatched from the component.
 * It also tracks bubbled/forwarded events.
 *
 * It can not track events which are not fired through a variable
 * which was not instantiated within the component with `createEventDispatcher`.
 * This means that event dispatchers which are defined outside of the component and then imported do not get picked up.
 *
 * The logic is as follows:
 * - If there exists a ComponentEvents interface definition, use that and skip the rest
 * - Else first try to find the `createEventDispatcher` import
 * - If it exists, try to find the variable where `createEventDispatcher()` is assigned to
 * - If that variable is found, try to find out if it's typed.
 *   - If yes, extract the event names and the event types from it
 *   - If no, track all invocations of it to get the event names
 */
class ComponentEvents {
    constructor(eventHandler) {
        this.componentEventsFromEventsMap = new ComponentEventsFromEventsMap(eventHandler);
    }
    get eventsClass() {
        return this.componentEventsInterface || this.componentEventsFromEventsMap;
    }
    /**
     * Collect state and create the API which will be part
     * of the return object of the `svelte2tsx` function.
     */
    createAPI() {
        const entries = [];
        const iterableEntries = this.eventsClass.events.entries();
        for (const entry of iterableEntries) {
            entries.push({ name: entry[0], ...entry[1] });
        }
        return {
            getAll() {
                return entries;
            }
        };
    }
    setComponentEventsInterface(node) {
        this.componentEventsInterface = new ComponentEventsFromInterface(node);
    }
    hasInterface() {
        return !!this.componentEventsInterface;
    }
    checkIfImportIsEventDispatcher(node) {
        this.componentEventsFromEventsMap.checkIfImportIsEventDispatcher(node);
    }
    checkIfIsStringLiteralDeclaration(node) {
        this.componentEventsFromEventsMap.checkIfIsStringLiteralDeclaration(node);
    }
    checkIfDeclarationInstantiatedEventDispatcher(node) {
        this.componentEventsFromEventsMap.checkIfDeclarationInstantiatedEventDispatcher(node);
    }
    checkIfCallExpressionIsDispatch(node) {
        this.componentEventsFromEventsMap.checkIfCallExpressionIsDispatch(node);
    }
    toDefString() {
        return this.eventsClass.toDefString();
    }
}
class ComponentEventsFromInterface {
    constructor(node) {
        this.events = new Map();
        this.events = this.extractEvents(node);
    }
    toDefString() {
        return '{} as unknown as ComponentEvents';
    }
    extractEvents(node) {
        const map = new Map();
        node.members.filter(ts__default.isPropertySignature).forEach((member) => {
            var _a;
            map.set(getName(member.name), {
                type: ((_a = member.type) === null || _a === void 0 ? void 0 : _a.getText()) || 'Event',
                doc: getDoc(member)
            });
        });
        return map;
    }
}
class ComponentEventsFromEventsMap {
    constructor(eventHandler) {
        this.eventHandler = eventHandler;
        this.events = new Map();
        this.dispatchedEvents = new Set();
        this.stringVars = new Map();
        this.eventDispatcherImport = '';
        this.dispatcherName = '';
        this.events = this.extractEvents(eventHandler);
    }
    checkIfImportIsEventDispatcher(node) {
        var _a;
        if (this.eventDispatcherImport) {
            return;
        }
        if (ts__default.isStringLiteral(node.moduleSpecifier) && node.moduleSpecifier.text !== 'svelte') {
            return;
        }
        const namedImports = (_a = node.importClause) === null || _a === void 0 ? void 0 : _a.namedBindings;
        if (ts__default.isNamedImports(namedImports)) {
            const eventDispatcherImport = namedImports.elements.find(
            // If it's an aliased import, propertyName is set
            (el) => (el.propertyName || el.name).text === 'createEventDispatcher');
            if (eventDispatcherImport) {
                this.eventDispatcherImport = eventDispatcherImport.name.text;
            }
        }
    }
    checkIfIsStringLiteralDeclaration(node) {
        if (ts__default.isIdentifier(node.name) &&
            node.initializer &&
            ts__default.isStringLiteral(node.initializer)) {
            this.stringVars.set(node.name.text, node.initializer.text);
        }
    }
    checkIfDeclarationInstantiatedEventDispatcher(node) {
        var _a;
        if (!ts__default.isIdentifier(node.name) || !node.initializer) {
            return;
        }
        if (ts__default.isCallExpression(node.initializer) &&
            ts__default.isIdentifier(node.initializer.expression) &&
            node.initializer.expression.text === this.eventDispatcherImport) {
            this.dispatcherName = node.name.text;
            const dispatcherTyping = (_a = node.initializer.typeArguments) === null || _a === void 0 ? void 0 : _a[0];
            if (dispatcherTyping && ts__default.isTypeLiteralNode(dispatcherTyping)) {
                this.eventDispatcherTyping = dispatcherTyping.getText();
                dispatcherTyping.members.filter(ts__default.isPropertySignature).forEach((member) => {
                    var _a;
                    this.addToEvents(getName(member.name), {
                        type: `CustomEvent<${((_a = member.type) === null || _a === void 0 ? void 0 : _a.getText()) || 'any'}>`,
                        doc: getDoc(member)
                    });
                });
            }
            else {
                this.eventHandler
                    .getDispatchedEventsForIdentifier(this.dispatcherName)
                    .forEach((evtName) => this.addToEvents(evtName));
            }
        }
    }
    checkIfCallExpressionIsDispatch(node) {
        if (!this.eventDispatcherTyping &&
            ts__default.isIdentifier(node.expression) &&
            node.expression.text === this.dispatcherName) {
            const firstArg = node.arguments[0];
            if (ts__default.isStringLiteral(firstArg)) {
                this.addToEvents(firstArg.text);
            }
            else if (ts__default.isIdentifier(firstArg)) {
                const str = this.stringVars.get(firstArg.text);
                if (str) {
                    this.addToEvents(str);
                }
            }
        }
    }
    addToEvents(eventName, info = { type: 'CustomEvent<any>' }) {
        this.events.set(eventName, info);
        this.dispatchedEvents.add(eventName);
    }
    toDefString() {
        if (this.eventDispatcherTyping) {
            return `__sveltets_toEventTypings<${this.eventDispatcherTyping}>()`;
        }
        return ('{' +
            this.eventHandler.bubbledEventsMapToString() +
            [...this.dispatchedEvents.keys()]
                .map((e) => `'${e}': __sveltets_customEvent`)
                .join(', ') +
            '}');
    }
    extractEvents(eventHandler) {
        const map = new Map();
        for (const name of eventHandler.getBubbledEvents().keys()) {
            map.set(name, { type: 'Event' });
        }
        return map;
    }
}
function getName(prop) {
    if (ts__default.isIdentifier(prop) || ts__default.isStringLiteral(prop)) {
        return prop.text;
    }
    if (ts__default.isComputedPropertyName(prop)) {
        if (ts__default.isIdentifier(prop.expression)) {
            const identifierName = prop.expression.text;
            const identifierValue = getIdentifierValue(prop, identifierName);
            if (!identifierValue) {
                throwError(prop);
            }
            return identifierValue;
        }
    }
    throwError(prop);
}
function getIdentifierValue(prop, identifierName) {
    const variable = getVariableAtTopLevel(prop.getSourceFile(), identifierName);
    if (variable && ts__default.isStringLiteral(variable.initializer)) {
        return variable.initializer.text;
    }
}
function throwError(prop) {
    const error = new Error('The ComponentEvents interface can only have properties of type ' +
        'Identifier, StringLiteral or ComputedPropertyName. ' +
        'In case of ComputedPropertyName, ' +
        'it must be a const declared within the component and initialized with a string.');
    error.start = toLineColumn(prop.getStart());
    error.end = toLineColumn(prop.getEnd());
    throw error;
    function toLineColumn(pos) {
        const lineChar = prop.getSourceFile().getLineAndCharacterOfPosition(pos);
        return {
            line: lineChar.line + 1,
            column: lineChar.character
        };
    }
}
function getDoc(member) {
    let doc = undefined;
    const comment = getLastLeadingDoc(member);
    if (comment) {
        doc = comment
            .split('\n')
            .map((line) => 
        // Remove /** */
        line
            .replace(/\s*\/\*\*/, '')
            .replace(/\s*\*\//, '')
            .replace(/\s*\*/, '')
            .trim())
            .join('\n');
    }
    return doc;
}

class EventHandler {
    constructor() {
        this.bubbledEvents = new Map();
        this.callees = [];
    }
    handleEventHandler(node, parent) {
        const eventName = node.name;
        // pass-through/ bubble
        if (!node.expression) {
            if (parent.type === 'InlineComponent') {
                this.handleEventHandlerBubble(parent, eventName);
            }
            else {
                this.bubbledEvents.set(eventName, getEventDefExpressionForNonCompoent(eventName, parent));
            }
        }
    }
    handleIdentifier(node, parent, prop) {
        if (prop === 'callee') {
            this.callees.push({ name: node.name, parent });
        }
    }
    getBubbledEvents() {
        return this.bubbledEvents;
    }
    getDispatchedEventsForIdentifier(name) {
        const eventNames = new Set();
        this.callees.forEach((callee) => {
            if (callee.name === name) {
                const [name] = callee.parent.arguments;
                if (name.value !== undefined) {
                    eventNames.add(name.value);
                }
            }
        });
        return eventNames;
    }
    bubbledEventsMapToString() {
        return Array.from(this.bubbledEvents.entries()).map(eventMapEntryToString).join(', ');
    }
    handleEventHandlerBubble(parent, eventName) {
        const componentEventDef = `__sveltets_instanceOf(${parent.name})`;
        const exp = `__sveltets_bubbleEventDef(${componentEventDef}.$$events_def, '${eventName}')`;
        const exist = this.bubbledEvents.get(eventName);
        this.bubbledEvents.set(eventName, exist ? [].concat(exist, exp) : exp);
    }
}
function getEventDefExpressionForNonCompoent(eventName, ele) {
    switch (ele.type) {
        case 'Element':
            return `__sveltets_mapElementEvent('${eventName}')`;
        case 'Body':
            return `__sveltets_mapBodyEvent('${eventName}')`;
        case 'Window':
            return `__sveltets_mapWindowEvent('${eventName}')`;
    }
}
function eventMapEntryToString([eventName, expression]) {
    return `'${eventName}':${Array.isArray(expression) ? `__sveltets_unionType(${expression.join(',')})` : expression}`;
}

class ExportedNames extends Map {
    /**
     * Adds export to map
     */
    addExport(name, target = null, type = null, required = false) {
        if (name.kind != ts__default.SyntaxKind.Identifier) {
            throw Error('export source kind not supported ' + name);
        }
        if (target && target.kind != ts__default.SyntaxKind.Identifier) {
            throw Error('export target kind not supported ' + target);
        }
        if (target) {
            this.set(name.text, {
                type: type === null || type === void 0 ? void 0 : type.getText(),
                identifierText: target.text,
                required,
                doc: this.getDoc(target)
            });
        }
        else {
            this.set(name.text, {});
        }
    }
    getDoc(target) {
        var _a, _b;
        let doc = undefined;
        // Traverse `a` up to `export let a`
        const exportExpr = (_b = (_a = target === null || target === void 0 ? void 0 : target.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent;
        if (exportExpr) {
            doc = getLastLeadingDoc(exportExpr);
        }
        return doc;
    }
    /**
     * Creates a string from the collected props
     *
     * @param isTsFile Whether this is a TypeScript file or not.
     */
    createPropsStr(isTsFile) {
        const names = Array.from(this.entries());
        const dontAddTypeDef = !isTsFile ||
            names.length === 0 ||
            names.every(([_, value]) => !value.type && value.required);
        const returnElements = names.map(([key, value]) => {
            // Important to not use shorthand props for rename functionality
            return `${dontAddTypeDef && value.doc ? `\n${value.doc}` : ''}${value.identifierText || key}: ${key}`;
        });
        if (dontAddTypeDef) {
            // No exports or only `typeof` exports -> omit the `as {...}` completely.
            // If not TS, omit the types to not have a "cannot use types in jsx" error.
            return `{${returnElements.join(' , ')}}`;
        }
        const returnElementsType = names.map(([key, value]) => {
            const identifier = `${value.doc ? `\n${value.doc}` : ''}${value.identifierText || key}${value.required ? '' : '?'}`;
            if (!value.type) {
                return `${identifier}: typeof ${key}`;
            }
            return `${identifier}: ${value.type}`;
        });
        return `{${returnElements.join(' , ')}} as {${returnElementsType.join(', ')}}`;
    }
}

const createClassGetter = (name) => `\n${' '.repeat(4)}get ${name}() { return render().getters.${name} }`;
const createClassGetters = (names) => {
    return Array.from(names).map(createClassGetter).join('');
};
function createRenderFunctionGetterStr(getters) {
    const properties = Array.from(getters).map((name) => `${name}: ${name}`);
    return `{${properties.join(', ')}}`;
}

/**
 *
 * @param {Node} param
 * @param {Identifier[]} nodes
 * @returns {Identifier[]}
 */
function extract_identifiers(param, nodes = []) {
	switch (param.type) {
		case 'Identifier':
			nodes.push(param);
			break;

		case 'MemberExpression':
			let object = param;
			while (object.type === 'MemberExpression') {
				object = /** @type {any} */ (object.object);
			}
			nodes.push(/** @type {any} */ (object));
			break;

		case 'ObjectPattern':
			/**
			 *
			 * @param {Property | RestElement} prop
			 */
			const handle_prop = (prop) => {
				if (prop.type === 'RestElement') {
					extract_identifiers(prop.argument, nodes);
				} else {
					extract_identifiers(prop.value, nodes);
				}
			};

			param.properties.forEach(handle_prop);
			break;

		case 'ArrayPattern':
			/**
			 *
			 * @param {Node} element
			 */
			const handle_element = (element) => {
				if (element) extract_identifiers(element, nodes);
			};

			param.elements.forEach(handle_element);
			break;

		case 'RestElement':
			extract_identifiers(param.argument, nodes);
			break;

		case 'AssignmentPattern':
			extract_identifiers(param.left, nodes);
			break;
	}

	return nodes;
}

function handleScopeAndResolveForSlot({ identifierDef, initExpression, owner, slotHandler, templateScope }) {
    if (isIdentifier(identifierDef)) {
        templateScope.add(identifierDef, owner);
        slotHandler.resolve(identifierDef, initExpression, templateScope);
    }
    if (isDestructuringPatterns(identifierDef)) {
        // the node object is returned as-it with no mutation
        const identifiers = extract_identifiers(identifierDef);
        templateScope.addMany(identifiers, owner);
        slotHandler.resolveDestructuringAssignment(identifierDef, identifiers, initExpression, templateScope);
    }
}
function handleScopeAndResolveLetVarForSlot({ letNode, component, slotName, templateScope, slotHandler }) {
    const { expression } = letNode;
    // <Component let:a>
    if (!expression) {
        templateScope.add(letNode, component);
        slotHandler.resolveLet(letNode, letNode, component, slotName);
    }
    else {
        if (isIdentifier(expression)) {
            templateScope.add(expression, component);
            slotHandler.resolveLet(letNode, expression, component, slotName);
        }
        const expForExtract = { ...expression };
        // https://github.com/sveltejs/svelte/blob/3a37de364bfbe75202d8e9fcef9e76b9ce6faaa2/src/compiler/compile/nodes/Let.ts#L37
        if (expression.type === 'ArrayExpression') {
            expForExtract.type = 'ArrayPattern';
        }
        else if (expression.type === 'ObjectExpression') {
            expForExtract.type = 'ObjectPattern';
        }
        if (isDestructuringPatterns(expForExtract)) {
            const identifiers = extract_identifiers(expForExtract);
            templateScope.addMany(identifiers, component);
            slotHandler.resolveDestructuringAssignmentForLet(expForExtract, identifiers, letNode, component, slotName);
        }
    }
}

/**
 * Tracks all store-usages as well as all variable declarations and imports in the component.
 *
 * In the modification-step at the end, all variable declartaions and imports which
 * were used as stores are appended with `let $xx = __sveltets_store_get(xx)` to create the store variables.
 */
class ImplicitStoreValues {
    constructor(storesResolvedInTemplate = []) {
        this.accessedStores = new Set();
        this.variableDeclarations = [];
        this.reactiveDeclarations = [];
        this.importStatements = [];
        this.addStoreAcess = this.accessedStores.add.bind(this.accessedStores);
        this.addVariableDeclaration = this.variableDeclarations.push.bind(this.variableDeclarations);
        this.addReactiveDeclaration = this.reactiveDeclarations.push.bind(this.reactiveDeclarations);
        this.addImportStatement = this.importStatements.push.bind(this.importStatements);
        storesResolvedInTemplate.forEach(this.addStoreAcess);
    }
    /**
     * All variable declartaions and imports which
     * were used as stores are appended with `let $xx = __sveltets_store_get(xx)` to create the store variables.
     */
    modifyCode(astOffset, str) {
        this.variableDeclarations.forEach((node) => this.attachStoreValueDeclarationToDecl(node, astOffset, str));
        this.reactiveDeclarations.forEach((node) => this.attachStoreValueDeclarationToReactiveAssignment(node, astOffset, str));
        this.importStatements
            .filter(({ name }) => name && this.accessedStores.has(name.getText()))
            .forEach((node) => this.attachStoreValueDeclarationToImport(node, astOffset, str));
    }
    attachStoreValueDeclarationToDecl(node, astOffset, str) {
        const storeNames = extractIdentifiers(node.name)
            .map((id) => id.text)
            .filter((name) => this.accessedStores.has(name));
        let toAppend = '';
        for (let i = 0; i < storeNames.length; i++) {
            toAppend += `;let $${storeNames[i]} = __sveltets_store_get(${storeNames[i]});`;
        }
        const endPos = node.getEnd() + astOffset;
        str.appendRight(endPos, toAppend);
    }
    attachStoreValueDeclarationToReactiveAssignment(node, astOffset, str) {
        const storeNames = getNamesFromLabeledStatement(node).filter((name) => this.accessedStores.has(name));
        let toAppend = '';
        for (let i = 0; i < storeNames.length; i++) {
            toAppend += `;let $${storeNames[i]} = __sveltets_store_get(${storeNames[i]});`;
        }
        const endPos = node.getEnd() + astOffset;
        str.appendRight(endPos, toAppend);
    }
    attachStoreValueDeclarationToImport(node, astOffset, str) {
        const storeName = node.name.getText();
        const importStatement = ts__default.isImportClause(node) ? node.parent : node.parent.parent.parent;
        const endPos = importStatement.getEnd() + astOffset;
        str.appendRight(endPos, `;let $${storeName} = __sveltets_store_get(${storeName});`);
    }
}

class Scripts {
    constructor(htmlxAst) {
        this.htmlxAst = htmlxAst;
        // All script tags, no matter at what level, are listed within the root children.
        // To get the top level scripts, filter out all those that are part of children's children.
        // Those have another type ('Element' with name 'script').
        this.scriptTags = this.htmlxAst.children.filter((child) => child.type === 'Script');
        this.topLevelScripts = this.scriptTags;
        this.handleScriptTag = (node, parent) => {
            if (parent !== this.htmlxAst && node.name === 'script') {
                this.topLevelScripts = this.topLevelScripts.filter((tag) => tag.start !== node.start || tag.end !== node.end);
            }
        };
    }
    getTopLevelScriptTags() {
        let scriptTag = null;
        let moduleScriptTag = null;
        // should be 2 at most, one each, so using forEach is safe
        this.topLevelScripts.forEach((tag) => {
            if (tag.attributes &&
                tag.attributes.find((a) => a.name == 'context' && a.value.length == 1 && a.value[0].raw == 'module')) {
                moduleScriptTag = tag;
            }
            else {
                scriptTag = tag;
            }
        });
        return { scriptTag, moduleScriptTag };
    }
    blankOtherScriptTags(str) {
        this.scriptTags
            .filter((tag) => !this.topLevelScripts.includes(tag))
            .forEach((tag) => {
            str.remove(tag.start, tag.end);
        });
    }
}

function handleStore(node, parent, str) {
    const storename = node.name.slice(1);
    //handle assign to
    if (parent.type == 'AssignmentExpression' && parent.left == node && parent.operator == '=') {
        const dollar = str.original.indexOf('$', node.start);
        str.remove(dollar, dollar + 1);
        str.overwrite(node.end, str.original.indexOf('=', node.end) + 1, '.set(');
        str.appendLeft(parent.end, ')');
        return;
    }
    // handle Assignment operators ($store +=, -=, *=, /=, %=, **=, etc.)
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Assignment
    const operators = ['+=', '-=', '*=', '/=', '%=', '**=', '<<=', '>>=', '>>>=', '&=', '^=', '|='];
    if (parent.type == 'AssignmentExpression' &&
        parent.left == node &&
        operators.includes(parent.operator)) {
        const storename = node.name.slice(1); // drop the $
        const operator = parent.operator.substring(0, parent.operator.length - 1); // drop the = sign
        str.overwrite(parent.start, str.original.indexOf('=', node.end) + 1, `${storename}.set( $${storename} ${operator}`);
        str.appendLeft(parent.end, ')');
        return;
    }
    // handle $store++, $store--, ++$store, --$store
    if (parent.type == 'UpdateExpression') {
        let simpleOperator;
        if (parent.operator === '++')
            simpleOperator = '+';
        if (parent.operator === '--')
            simpleOperator = '-';
        if (simpleOperator) {
            const storename = node.name.slice(1); // drop the $
            str.overwrite(parent.start, parent.end, `${storename}.set( $${storename} ${simpleOperator} 1)`);
        }
        else {
            console.warn(`Warning - unrecognized UpdateExpression operator ${parent.operator}!
                This is an edge case unaccounted for in svelte2tsx, please file an issue:
                https://github.com/sveltejs/language-tools/issues/new/choose
                `, str.original.slice(parent.start, parent.end));
        }
        return;
    }
    // we change "$store" references into "(__sveltets_store_get(store), $store)"
    // - in order to get ts errors if store is not assignable to SvelteStore
    // - use $store variable defined above to get ts flow control
    const dollar = str.original.indexOf('$', node.start);
    str.overwrite(dollar, dollar + 1, '(__sveltets_store_get(');
    str.prependLeft(node.end, `), $${storename})`);
}
const reservedNames = new Set(['$$props', '$$restProps', '$$slots']);
class Stores {
    constructor(scope, str, isDeclaration) {
        this.scope = scope;
        this.str = str;
        this.isDeclaration = isDeclaration;
        this.pendingStoreResolutions = [];
    }
    handleIdentifier(node, parent, prop) {
        if (node.name[0] !== '$' || reservedNames.has(node.name)) {
            return;
        }
        //handle potential store
        if (this.isDeclaration.value) {
            if (isObjectKey(parent, prop)) {
                return;
            }
            this.scope.current.declared.add(node.name);
        }
        else {
            if (isMember(parent, prop) && !parent.computed) {
                return;
            }
            if (isObjectKey(parent, prop)) {
                return;
            }
            this.pendingStoreResolutions.push({ node, parent, scope: this.scope.current });
        }
    }
    resolveStores() {
        const unresolvedStores = this.pendingStoreResolutions.filter(({ node, scope }) => {
            const name = node.name;
            // if variable starting with '$' was manually declared by the user,
            // this isn't a store access.
            return !scope.hasDefined(name);
        });
        unresolvedStores.forEach(({ node, parent }) => handleStore(node, parent, this.str));
        return unresolvedStores.map(({ node }) => node.name.slice(1));
    }
}

/**
 * adopted from https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/nodes/shared/TemplateScope.ts
 */
class TemplateScope {
    constructor(parent) {
        this.owners = new Map();
        this.inits = new Map();
        this.parent = parent;
        this.names = new Set(parent ? parent.names : []);
    }
    addMany(inits, owner) {
        inits.forEach((item) => this.add(item, owner));
        return this;
    }
    add(init, owner) {
        const { name } = init;
        this.names.add(name);
        this.inits.set(name, init);
        this.owners.set(name, owner);
        return this;
    }
    child() {
        const child = new TemplateScope(this);
        return child;
    }
    getOwner(name) {
        var _a;
        return this.owners.get(name) || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.getOwner(name));
    }
    getInit(name) {
        var _a;
        return this.inits.get(name) || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.getInit(name));
    }
    isLet(name) {
        const owner = this.getOwner(name);
        return owner && (owner.type === 'Element' || owner.type === 'InlineComponent');
    }
}

class ImplicitTopLevelNames {
    constructor() {
        this.map = new Set();
    }
    add(node) {
        this.map.add(node);
    }
    modifyCode(rootVariables, astOffset, str) {
        for (const node of this.map.values()) {
            const names = getNamesFromLabeledStatement(node);
            if (names.length === 0) {
                continue;
            }
            const implicitTopLevelNames = names.filter((name) => !rootVariables.has(name));
            const pos = node.label.getStart();
            if (this.hasOnlyImplicitTopLevelNames(names, implicitTopLevelNames)) {
                // remove '$:' label
                str.remove(pos + astOffset, pos + astOffset + 2);
                str.prependRight(pos + astOffset, 'let ');
                this.removeBracesFromParenthizedExpression(node, astOffset, str);
            }
            else {
                implicitTopLevelNames.forEach((name) => {
                    str.prependRight(pos + astOffset, `let ${name};\n`);
                });
            }
        }
    }
    hasOnlyImplicitTopLevelNames(names, implicitTopLevelNames) {
        return names.length === implicitTopLevelNames.length;
    }
    removeBracesFromParenthizedExpression(node, astOffset, str) {
        // If expression is of type `$: ({a} = b);`,
        // remove the surrounding braces so that the transformation
        // to `let {a} = b;` produces valid code.
        if (ts__default.isExpressionStatement(node.statement) &&
            isParenthesizedObjectOrArrayLiteralExpression(node.statement.expression)) {
            const start = node.statement.expression.getStart() + astOffset;
            str.overwrite(start, start + 1, '', { contentOnly: true });
            const end = node.statement.expression.getEnd() + astOffset - 1;
            str.overwrite(end, end + 1, '', { contentOnly: true });
        }
    }
}

class Scope {
    constructor(parent) {
        this.declared = new Set();
        this.parent = parent;
    }
    hasDefined(name) {
        return this.declared.has(name) || (!!this.parent && this.parent.hasDefined(name));
    }
}
class ScopeStack {
    constructor() {
        this.current = new Scope();
    }
    push() {
        this.current = new Scope(this.current);
    }
    pop() {
        this.current = this.current.parent;
    }
}

/**
 * Transform type assertion to as expression: <Type>a => a as Type
 */
function handleTypeAssertion(str, assertion, astOffset) {
    const { expression, type } = assertion;
    const assertionStart = assertion.getStart() + astOffset;
    const typeStart = type.getStart() + astOffset;
    const typeEnd = type.getEnd() + astOffset;
    const expressionStart = expression.getStart() + astOffset;
    const expressionEnd = expression.getEnd() + astOffset;
    str.appendLeft(expressionEnd, ' as ');
    // move 'HTMLElement' to the end of expression
    str.move(assertionStart, typeEnd, expressionEnd);
    str.remove(assertionStart, typeStart);
    // remove '>'
    str.remove(typeEnd, expressionStart);
}

function processInstanceScriptContent(str, script, events, implicitStoreValues) {
    const htmlx = str.original;
    const scriptContent = htmlx.substring(script.content.start, script.content.end);
    const tsAst = createSourceFile('component.ts.svelte', scriptContent, ScriptTarget.Latest, true, ScriptKind.TS);
    const astOffset = script.content.start;
    const exportedNames = new ExportedNames();
    const getters = new Set();
    const implicitTopLevelNames = new ImplicitTopLevelNames();
    let uses$$props = false;
    let uses$$restProps = false;
    let uses$$slots = false;
    //track if we are in a declaration scope
    let isDeclaration = false;
    //track $store variables since we are only supposed to give top level scopes special treatment, and users can declare $blah variables at higher scopes
    //which prevents us just changing all instances of Identity that start with $
    const pendingStoreResolutions = [];
    let scope = new Scope();
    const rootScope = scope;
    const pushScope = () => (scope = new Scope(scope));
    const popScope = () => (scope = scope.parent);
    const addGetter = (node) => {
        if (!node) {
            return;
        }
        getters.add(node.text);
    };
    const removeExport = (start, end) => {
        const exportStart = str.original.indexOf('export', start + astOffset);
        const exportEnd = exportStart + (end - start);
        str.remove(exportStart, exportEnd);
    };
    const propTypeAssertToUserDefined = (node) => {
        const hasInitializers = node.declarations.filter((declaration) => declaration.initializer);
        const handleTypeAssertion = (declaration) => {
            var _a;
            const identifier = declaration.name;
            const tsType = declaration.type;
            const jsDocType = getJSDocType(declaration);
            const type = tsType || jsDocType;
            if (!isIdentifier$1(identifier) ||
                (!type &&
                    // Edge case: TS infers `export let bla = false` to type `false`.
                    // prevent that by adding the any-wrap in this case, too.
                    ![SyntaxKind.FalseKeyword, SyntaxKind.TrueKeyword].includes((_a = declaration.initializer) === null || _a === void 0 ? void 0 : _a.kind))) {
                return;
            }
            const name = identifier.getText();
            const end = declaration.end + astOffset;
            str.appendLeft(end, `;${name} = __sveltets_any(${name});`);
        };
        const findComma = (target) => target.getChildren().filter((child) => child.kind === SyntaxKind.CommaToken);
        const splitDeclaration = () => {
            const commas = node
                .getChildren()
                .filter((child) => child.kind === SyntaxKind.SyntaxList)
                .map(findComma)
                .reduce((current, previous) => [...current, ...previous], []);
            commas.forEach((comma) => {
                const start = comma.getStart() + astOffset;
                const end = comma.getEnd() + astOffset;
                str.overwrite(start, end, ';let ', { contentOnly: true });
            });
        };
        splitDeclaration();
        for (const declaration of hasInitializers) {
            handleTypeAssertion(declaration);
        }
    };
    const handleExportFunctionOrClass = (node) => {
        const exportModifier = findExportKeyword(node);
        if (!exportModifier) {
            return;
        }
        removeExport(exportModifier.getStart(), exportModifier.end);
        addGetter(node.name);
        // Can't export default here
        if (node.name) {
            exportedNames.addExport(node.name);
        }
    };
    const handleStore = (ident, parent) => {
        const storename = ident.getText().slice(1); // drop the $
        // handle assign to
        // eslint-disable-next-line max-len
        if (parent &&
            isBinaryExpression(parent) &&
            parent.operatorToken.kind == SyntaxKind.EqualsToken &&
            parent.left == ident) {
            //remove $
            const dollar = str.original.indexOf('$', ident.getStart() + astOffset);
            str.remove(dollar, dollar + 1);
            // replace = with .set(
            str.overwrite(ident.end + astOffset, parent.operatorToken.end + astOffset, '.set(');
            // append )
            str.appendLeft(parent.end + astOffset, ')');
            return;
        }
        // ignore break
        if (parent && parent.kind === SyntaxKind.BreakStatement) {
            return;
        }
        // handle Assignment operators ($store +=, -=, *=, /=, %=, **=, etc.)
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Assignment
        const operators = {
            [SyntaxKind.PlusEqualsToken]: '+',
            [SyntaxKind.MinusEqualsToken]: '-',
            [SyntaxKind.AsteriskEqualsToken]: '*',
            [SyntaxKind.SlashEqualsToken]: '/',
            [SyntaxKind.PercentEqualsToken]: '%',
            [SyntaxKind.AsteriskAsteriskEqualsToken]: '**',
            [SyntaxKind.LessThanLessThanEqualsToken]: '<<',
            [SyntaxKind.GreaterThanGreaterThanEqualsToken]: '>>',
            [SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken]: '>>>',
            [SyntaxKind.AmpersandEqualsToken]: '&',
            [SyntaxKind.CaretEqualsToken]: '^',
            [SyntaxKind.BarEqualsToken]: '|'
        };
        if (isBinaryExpression(parent) &&
            parent.left == ident &&
            Object.keys(operators).find((x) => x === String(parent.operatorToken.kind))) {
            const operator = operators[parent.operatorToken.kind];
            str.overwrite(parent.getStart() + astOffset, str.original.indexOf('=', ident.end + astOffset) + 1, `${storename}.set( $${storename} ${operator}`);
            str.appendLeft(parent.end + astOffset, ')');
            return;
        }
        // handle $store++, $store--, ++$store, --$store
        if ((isPrefixUnaryExpression(parent) || isPostfixUnaryExpression(parent)) &&
            parent.operator !==
                SyntaxKind.ExclamationToken /* `!$store` does not need processing */) {
            let simpleOperator;
            if (parent.operator === SyntaxKind.PlusPlusToken) {
                simpleOperator = '+';
            }
            if (parent.operator === SyntaxKind.MinusMinusToken) {
                simpleOperator = '-';
            }
            if (simpleOperator) {
                str.overwrite(parent.getStart() + astOffset, parent.end + astOffset, `${storename}.set( $${storename} ${simpleOperator} 1)`);
                return;
            }
            else {
                console.warn(`Warning - unrecognized UnaryExpression operator ${parent.operator}!
                This is an edge case unaccounted for in svelte2tsx, please file an issue:
                https://github.com/sveltejs/language-tools/issues/new/choose
                `, parent.getText());
            }
        }
        // we change "$store" references into "(__sveltets_store_get(store), $store)"
        // - in order to get ts errors if store is not assignable to SvelteStore
        // - use $store variable defined above to get ts flow control
        const dollar = str.original.indexOf('$', ident.getStart() + astOffset);
        str.overwrite(dollar, dollar + 1, '(__sveltets_store_get(');
        str.prependLeft(ident.end + astOffset, `), $${storename})`);
    };
    const resolveStore = (pending) => {
        let { node, parent, scope } = pending;
        const name = node.text;
        while (scope) {
            if (scope.declared.has(name)) {
                //we were manually declared, this isn't a store access.
                return;
            }
            scope = scope.parent;
        }
        //We haven't been resolved, we must be a store read/write, handle it.
        handleStore(node, parent);
        const storename = node.getText().slice(1);
        implicitStoreValues.addStoreAcess(storename);
    };
    const handleIdentifier = (ident, parent) => {
        if (ident.text === '$$props') {
            uses$$props = true;
            return;
        }
        if (ident.text === '$$restProps') {
            uses$$restProps = true;
            return;
        }
        if (ident.text === '$$slots') {
            uses$$slots = true;
            return;
        }
        if (isLabeledStatement(parent) && parent.label == ident) {
            return;
        }
        if (isDeclaration || isParameter(parent)) {
            if (isNotPropertyNameOfImport(ident) &&
                (!isBindingElement(ident.parent) || ident.parent.name == ident)) {
                // we are a key, not a name, so don't care
                if (ident.text.startsWith('$') || scope == rootScope) {
                    // track all top level declared identifiers and all $ prefixed identifiers
                    scope.declared.add(ident.text);
                }
            }
        }
        else {
            //track potential store usage to be resolved
            if (ident.text.startsWith('$')) {
                if ((!isPropertyAccessExpression(parent) || parent.expression == ident) &&
                    (!isPropertyAssignment(parent) || parent.initializer == ident) &&
                    !isPropertySignature(parent) &&
                    !isPropertyDeclaration(parent)) {
                    pendingStoreResolutions.push({ node: ident, parent, scope });
                }
            }
        }
    };
    const handleExportedVariableDeclarationList = (list) => {
        forEachChild(list, (node) => {
            if (isVariableDeclaration(node)) {
                if (isIdentifier$1(node.name)) {
                    exportedNames.addExport(node.name, node.name, node.type, !node.initializer);
                }
                else if (isObjectBindingPattern(node.name) ||
                    isArrayBindingPattern(node.name)) {
                    forEachChild(node.name, (element) => {
                        if (isBindingElement(element)) {
                            exportedNames.addExport(element.name);
                        }
                    });
                }
            }
        });
    };
    const wrapExpressionWithInvalidate = (expression) => {
        if (!expression) {
            return;
        }
        const start = expression.getStart() + astOffset;
        const end = expression.getEnd() + astOffset;
        // () => ({})
        if (isObjectLiteralExpression(expression)) {
            str.appendLeft(start, '(');
            str.appendRight(end, ')');
        }
        str.prependLeft(start, '__sveltets_invalidate(() => ');
        str.appendRight(end, ')');
        // Not adding ';' at the end because right now this function is only invoked
        // in situations where there is a line break of ; guaranteed to be present (else the code is invalid)
    };
    const walk = (node, parent) => {
        var _a;
        const onLeaveCallbacks = [];
        if (isInterfaceDeclaration(node) && node.name.text === 'ComponentEvents') {
            events.setComponentEventsInterface(node);
        }
        if (isVariableStatement(node)) {
            const exportModifier = findExportKeyword(node);
            if (exportModifier) {
                const isLet = node.declarationList.flags === NodeFlags.Let;
                const isConst = node.declarationList.flags === NodeFlags.Const;
                handleExportedVariableDeclarationList(node.declarationList);
                if (isLet) {
                    propTypeAssertToUserDefined(node.declarationList);
                }
                else if (isConst) {
                    node.declarationList.forEachChild((n) => {
                        if (isVariableDeclaration(n) && isIdentifier$1(n.name)) {
                            addGetter(n.name);
                        }
                    });
                }
                removeExport(exportModifier.getStart(), exportModifier.end);
            }
        }
        if (isFunctionDeclaration(node)) {
            handleExportFunctionOrClass(node);
            pushScope();
            onLeaveCallbacks.push(() => popScope());
        }
        if (isClassDeclaration(node)) {
            handleExportFunctionOrClass(node);
        }
        if (isBlock(node)) {
            pushScope();
            onLeaveCallbacks.push(() => popScope());
        }
        if (isArrowFunction(node)) {
            pushScope();
            onLeaveCallbacks.push(() => popScope());
        }
        if (isExportDeclaration(node)) {
            const { exportClause } = node;
            if (isNamedExports(exportClause)) {
                for (const ne of exportClause.elements) {
                    if (ne.propertyName) {
                        exportedNames.addExport(ne.propertyName, ne.name);
                    }
                    else {
                        exportedNames.addExport(ne.name);
                    }
                }
                //we can remove entire statement
                removeExport(node.getStart(), node.end);
            }
        }
        if (isImportDeclaration(node)) {
            //move imports to top of script so they appear outside our render function
            str.move(node.getStart() + astOffset, node.end + astOffset, script.start + 1);
            //add in a \n
            const originalEndChar = str.original[node.end + astOffset - 1];
            str.overwrite(node.end + astOffset - 1, node.end + astOffset, originalEndChar + '\n');
            // Check if import is the event dispatcher
            events.checkIfImportIsEventDispatcher(node);
        }
        if (isVariableDeclaration(node)) {
            events.checkIfIsStringLiteralDeclaration(node);
            events.checkIfDeclarationInstantiatedEventDispatcher(node);
            implicitStoreValues.addVariableDeclaration(node);
        }
        if (isCallExpression(node)) {
            events.checkIfCallExpressionIsDispatch(node);
        }
        if (isVariableDeclaration(parent) && parent.name == node) {
            isDeclaration = true;
            onLeaveCallbacks.push(() => (isDeclaration = false));
        }
        if (isBindingElement(parent) && parent.name == node) {
            isDeclaration = true;
            onLeaveCallbacks.push(() => (isDeclaration = false));
        }
        if (isImportClause(node)) {
            isDeclaration = true;
            onLeaveCallbacks.push(() => (isDeclaration = false));
            implicitStoreValues.addImportStatement(node);
        }
        if (isImportSpecifier(node)) {
            implicitStoreValues.addImportStatement(node);
        }
        //handle stores etc
        if (isIdentifier$1(node)) {
            handleIdentifier(node, parent);
        }
        //track implicit declarations in reactive blocks at the top level
        if (isLabeledStatement(node) &&
            parent == tsAst && //top level
            node.label.text == '$' &&
            node.statement) {
            const binaryExpression = getBinaryAssignmentExpr(node);
            if (binaryExpression) {
                implicitTopLevelNames.add(node);
                implicitStoreValues.addReactiveDeclaration(node);
                wrapExpressionWithInvalidate(binaryExpression.right);
            }
            else {
                const start = node.getStart() + astOffset;
                const end = node.getEnd() + astOffset;
                str.prependLeft(start, ';() => {');
                str.appendRight(end, '}');
            }
        }
        // Defensively call function (checking for undefined) because it got added only recently (TS 4.0)
        // and therefore might break people using older TS versions
        if ((_a = isTypeAssertionExpression) === null || _a === void 0 ? void 0 : _a.call(ts, node)) {
            handleTypeAssertion(str, node, astOffset);
        }
        //to save a bunch of condition checks on each node, we recurse into processChild which skips all the checks for top level items
        forEachChild(node, (n) => walk(n, node));
        //fire off the on leave callbacks
        onLeaveCallbacks.map((c) => c());
    };
    //walk the ast and convert to tsx as we go
    tsAst.forEachChild((n) => walk(n, tsAst));
    //resolve stores
    pendingStoreResolutions.map(resolveStore);
    // declare implicit reactive variables we found in the script
    implicitTopLevelNames.modifyCode(rootScope.declared, astOffset, str);
    implicitStoreValues.modifyCode(astOffset, str);
    const firstImport = tsAst.statements
        .filter(isImportDeclaration)
        .sort((a, b) => a.end - b.end)[0];
    if (firstImport) {
        str.appendRight(firstImport.getStart() + astOffset, '\n');
    }
    return {
        exportedNames,
        events,
        uses$$props,
        uses$$restProps,
        uses$$slots,
        getters
    };
}

function processModuleScriptTag(str, script) {
    const htmlx = str.original;
    const scriptStartTagEnd = htmlx.indexOf('>', script.start) + 1;
    const scriptEndTagStart = htmlx.lastIndexOf('<', script.end - 1);
    str.overwrite(script.start, scriptStartTagEnd, '</>;');
    str.overwrite(scriptEndTagStart, script.end, ';<>');
}

/**
 * A component class name suffix is necessary to prevent class name clashes
 * like reported in https://github.com/sveltejs/language-tools/issues/294
 */
const COMPONENT_SUFFIX = '__SvelteComponent_';
function processSvelteTemplate(str, options) {
    const htmlxAst = parseHtmlx(str.original, options);
    let uses$$props = false;
    let uses$$restProps = false;
    let uses$$slots = false;
    const componentDocumentation = new ComponentDocumentation();
    //track if we are in a declaration scope
    const isDeclaration = { value: false };
    //track $store variables since we are only supposed to give top level scopes special treatment, and users can declare $blah variables at higher scopes
    //which prevents us just changing all instances of Identity that start with $
    const scopeStack = new ScopeStack();
    const stores = new Stores(scopeStack, str, isDeclaration);
    const scripts = new Scripts(htmlxAst);
    const handleIdentifier = (node) => {
        if (node.name === '$$props') {
            uses$$props = true;
            return;
        }
        if (node.name === '$$restProps') {
            uses$$restProps = true;
            return;
        }
        if (node.name === '$$slots') {
            uses$$slots = true;
            return;
        }
    };
    const handleStyleTag = (node) => {
        str.remove(node.start, node.end);
    };
    const slotHandler = new SlotHandler(str.original);
    let templateScope = new TemplateScope();
    const handleEach = (node) => {
        templateScope = templateScope.child();
        if (node.context) {
            handleScopeAndResolveForSlotInner(node.context, node.expression, node);
        }
    };
    const handleAwait = (node) => {
        templateScope = templateScope.child();
        if (node.value) {
            handleScopeAndResolveForSlotInner(node.value, node.expression, node.then);
        }
        if (node.error) {
            handleScopeAndResolveForSlotInner(node.error, node.expression, node.catch);
        }
    };
    const handleComponentLet = (component) => {
        templateScope = templateScope.child();
        const lets = slotHandler.getSlotConsumerOfComponent(component);
        for (const { letNode, slotName } of lets) {
            handleScopeAndResolveLetVarForSlot({
                letNode,
                slotName,
                slotHandler,
                templateScope,
                component
            });
        }
    };
    const handleScopeAndResolveForSlotInner = (identifierDef, initExpression, owner) => {
        handleScopeAndResolveForSlot({
            identifierDef,
            initExpression,
            slotHandler,
            templateScope,
            owner
        });
    };
    const eventHandler = new EventHandler();
    const onHtmlxWalk = (node, parent, prop) => {
        if (prop == 'params' &&
            (parent.type == 'FunctionDeclaration' || parent.type == 'ArrowFunctionExpression')) {
            isDeclaration.value = true;
        }
        if (prop == 'id' && parent.type == 'VariableDeclarator') {
            isDeclaration.value = true;
        }
        switch (node.type) {
            case 'Comment':
                componentDocumentation.handleComment(node);
                break;
            case 'Identifier':
                handleIdentifier(node);
                stores.handleIdentifier(node, parent, prop);
                eventHandler.handleIdentifier(node, parent, prop);
                break;
            case 'Slot':
                slotHandler.handleSlot(node, templateScope);
                break;
            case 'Style':
                handleStyleTag(node);
                break;
            case 'Element':
                scripts.handleScriptTag(node, parent);
                break;
            case 'BlockStatement':
                scopeStack.push();
                break;
            case 'FunctionDeclaration':
                scopeStack.push();
                break;
            case 'ArrowFunctionExpression':
                scopeStack.push();
                break;
            case 'EventHandler':
                eventHandler.handleEventHandler(node, parent);
                break;
            case 'VariableDeclarator':
                isDeclaration.value = true;
                break;
            case 'EachBlock':
                handleEach(node);
                break;
            case 'AwaitBlock':
                handleAwait(node);
                break;
            case 'InlineComponent':
                handleComponentLet(node);
                break;
        }
    };
    const onHtmlxLeave = (node, parent, prop, _index) => {
        if (prop == 'params' &&
            (parent.type == 'FunctionDeclaration' || parent.type == 'ArrowFunctionExpression')) {
            isDeclaration.value = false;
        }
        if (prop == 'id' && parent.type == 'VariableDeclarator') {
            isDeclaration.value = false;
        }
        const onTemplateScopeLeave = () => {
            templateScope = templateScope.parent;
        };
        switch (node.type) {
            case 'BlockStatement':
                scopeStack.pop();
                break;
            case 'FunctionDeclaration':
                scopeStack.pop();
                break;
            case 'ArrowFunctionExpression':
                scopeStack.pop();
                break;
            case 'EachBlock':
                onTemplateScopeLeave();
                break;
            case 'AwaitBlock':
                onTemplateScopeLeave();
                break;
            case 'InlineComponent':
                onTemplateScopeLeave();
                break;
        }
    };
    convertHtmlxToJsx(str, htmlxAst, onHtmlxWalk, onHtmlxLeave);
    // resolve scripts
    const { scriptTag, moduleScriptTag } = scripts.getTopLevelScriptTags();
    scripts.blankOtherScriptTags(str);
    //resolve stores
    const resolvedStores = stores.resolveStores();
    return {
        moduleScriptTag,
        scriptTag,
        slots: slotHandler.getSlotDef(),
        events: new ComponentEvents(eventHandler),
        uses$$props,
        uses$$restProps,
        uses$$slots,
        componentDocumentation,
        resolvedStores
    };
}
function addComponentExport({ str, uses$$propsOr$$restProps, strictMode, strictEvents, isTsFile, getters, fileName, componentDocumentation }) {
    const eventsDef = strictEvents ? 'render' : '__sveltets_with_any_event(render)';
    const propDef = 
    // Omit partial-wrapper only if both strict mode and ts file, because
    // in a js file the user has no way of telling the language that
    // the prop is optional
    strictMode && isTsFile
        ? uses$$propsOr$$restProps
            ? `__sveltets_with_any(${eventsDef})`
            : eventsDef
        : `__sveltets_partial${isTsFile ? '_ts' : ''}${uses$$propsOr$$restProps ? '_with_any' : ''}(${eventsDef})`;
    const doc = componentDocumentation.getFormatted();
    const className = fileName && classNameFromFilename(fileName);
    const statement = `\n\n${doc}export default class${className ? ` ${className}` : ''} extends createSvelte2TsxComponent(${propDef}) {` +
        createClassGetters(getters) +
        '\n}';
    str.append(statement);
}
/**
 * Returns a Svelte-compatible component name from a filename. Svelte
 * components must use capitalized tags, so we try to transform the filename.
 *
 * https://svelte.dev/docs#Tags
 */
function classNameFromFilename(filename) {
    var _a;
    try {
        const withoutExtensions = (_a = path.parse(filename).name) === null || _a === void 0 ? void 0 : _a.split('.')[0];
        const withoutInvalidCharacters = withoutExtensions
            .split('')
            // Although "-" is invalid, we leave it in, pascal-case-handling will throw it out later
            .filter((char) => /[A-Za-z$_\d-]/.test(char))
            .join('');
        const firstValidCharIdx = withoutInvalidCharacters
            .split('')
            // Although _ and $ are valid first characters for classes, they are invalid first characters
            // for tag names. For a better import autocompletion experience, we therefore throw them out.
            .findIndex((char) => /[A-Za-z]/.test(char));
        const withoutLeadingInvalidCharacters = withoutInvalidCharacters.substr(firstValidCharIdx);
        const inPascalCase = pascalCase(withoutLeadingInvalidCharacters);
        const finalName = firstValidCharIdx === -1 ? `A${inPascalCase}` : inPascalCase;
        return `${finalName}${COMPONENT_SUFFIX}`;
    }
    catch (error) {
        console.warn(`Failed to create a name for the component class from filename ${filename}`);
        return undefined;
    }
}
function createRenderFunction({ str, scriptTag, scriptDestination, slots, getters, events, exportedNames, isTsFile, uses$$props, uses$$restProps, uses$$slots }) {
    const htmlx = str.original;
    let propsDecl = '';
    if (uses$$props) {
        propsDecl += ' let $$props = __sveltets_allPropsType();';
    }
    if (uses$$restProps) {
        propsDecl += ' let $$restProps = __sveltets_restPropsType();';
    }
    if (uses$$slots) {
        propsDecl +=
            ' let $$slots = __sveltets_slotsType({' +
                Array.from(slots.keys())
                    .map((name) => `'${name}': ''`)
                    .join(', ') +
                '});';
    }
    if (scriptTag) {
        //I couldn't get magicstring to let me put the script before the <> we prepend during conversion of the template to jsx, so we just close it instead
        const scriptTagEnd = htmlx.lastIndexOf('>', scriptTag.content.start) + 1;
        str.overwrite(scriptTag.start, scriptTag.start + 1, '</>;');
        str.overwrite(scriptTag.start + 1, scriptTagEnd, `function render() {${propsDecl}\n`);
        const scriptEndTagStart = htmlx.lastIndexOf('<', scriptTag.end - 1);
        // wrap template with callback
        str.overwrite(scriptEndTagStart, scriptTag.end, ';\n() => (<>', {
            contentOnly: true
        });
    }
    else {
        str.prependRight(scriptDestination, `</>;function render() {${propsDecl}\n<>`);
    }
    const slotsAsDef = '{' +
        Array.from(slots.entries())
            .map(([name, attrs]) => {
            const attrsAsString = Array.from(attrs.entries())
                .map(([exportName, expr]) => `${exportName}:${expr}`)
                .join(', ');
            return `'${name}': {${attrsAsString}}`;
        })
            .join(', ') +
        '}';
    const returnString = `\nreturn { props: ${exportedNames.createPropsStr(isTsFile)}, slots: ${slotsAsDef}, getters: ${createRenderFunctionGetterStr(getters)}` +
        `, events: ${events.toDefString()} }}`;
    // wrap template with callback
    if (scriptTag) {
        str.append(');');
    }
    str.append(returnString);
}
function svelte2tsx(svelte, options) {
    const str = new MagicString(svelte);
    // process the htmlx as a svelte template
    let { moduleScriptTag, scriptTag, slots, uses$$props, uses$$slots, uses$$restProps, events, componentDocumentation, resolvedStores } = processSvelteTemplate(str, options);
    /* Rearrange the script tags so that module is first, and instance second followed finally by the template
     * This is a bit convoluted due to some trouble I had with magic string. A simple str.move(start,end,0) for each script wasn't enough
     * since if the module script was already at 0, it wouldn't move (which is fine) but would mean the order would be swapped when the script tag tried to move to 0
     * In this case we instead have to move it to moduleScriptTag.end. We track the location for the script move in the MoveInstanceScriptTarget var
     */
    let instanceScriptTarget = 0;
    if (moduleScriptTag) {
        if (moduleScriptTag.start != 0) {
            //move our module tag to the top
            str.move(moduleScriptTag.start, moduleScriptTag.end, 0);
        }
        else {
            //since our module script was already at position 0, we need to move our instance script tag to the end of it.
            instanceScriptTarget = moduleScriptTag.end;
        }
    }
    //move the instance script and process the content
    let exportedNames = new ExportedNames();
    let getters = new Set();
    const implicitStoreValues = new ImplicitStoreValues(resolvedStores);
    if (scriptTag) {
        //ensure it is between the module script and the rest of the template (the variables need to be declared before the jsx template)
        if (scriptTag.start != instanceScriptTarget) {
            str.move(scriptTag.start, scriptTag.end, instanceScriptTarget);
        }
        const res = processInstanceScriptContent(str, scriptTag, events, implicitStoreValues);
        uses$$props = uses$$props || res.uses$$props;
        uses$$restProps = uses$$restProps || res.uses$$restProps;
        uses$$slots = uses$$slots || res.uses$$slots;
        ({ exportedNames, events, getters } = res);
    }
    //wrap the script tag and template content in a function returning the slot and exports
    createRenderFunction({
        str,
        scriptTag,
        scriptDestination: instanceScriptTarget,
        slots,
        events,
        getters,
        exportedNames,
        isTsFile: options === null || options === void 0 ? void 0 : options.isTsFile,
        uses$$props,
        uses$$restProps,
        uses$$slots
    });
    // we need to process the module script after the instance script has moved otherwise we get warnings about moving edited items
    if (moduleScriptTag) {
        processModuleScriptTag(str, moduleScriptTag);
    }
    addComponentExport({
        str,
        uses$$propsOr$$restProps: uses$$props || uses$$restProps,
        strictMode: !!(options === null || options === void 0 ? void 0 : options.strictMode),
        strictEvents: events.hasInterface(),
        isTsFile: options === null || options === void 0 ? void 0 : options.isTsFile,
        getters,
        fileName: options === null || options === void 0 ? void 0 : options.filename,
        componentDocumentation
    });
    str.prepend('///<reference types="svelte" />\n');
    return {
        code: str.toString(),
        map: str.generateMap({ hires: true, source: options === null || options === void 0 ? void 0 : options.filename }),
        exportedNames,
        events: events.createAPI()
    };
}

export default svelte2tsx;
