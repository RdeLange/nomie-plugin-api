"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateImportsProviderImpl = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../../lib/documents");
const utils_1 = require("../../../utils");
const utils_2 = require("../utils");
class UpdateImportsProviderImpl {
    constructor(lsAndTsDocResolver) {
        this.lsAndTsDocResolver = lsAndTsDocResolver;
    }
    async updateImports(fileRename) {
        const oldPath = utils_1.urlToPath(fileRename.oldUri);
        const newPath = utils_1.urlToPath(fileRename.newUri);
        if (!oldPath || !newPath) {
            return null;
        }
        const ls = this.getLSForPath(newPath);
        // `getEditsForFileRename` might take a while
        const fileChanges = ls.getEditsForFileRename(oldPath, newPath, {}, {});
        this.lsAndTsDocResolver.updateSnapshotPath(oldPath, newPath);
        const updateImportsChanges = fileChanges
            // Assumption: Updating imports will not create new files, and to make sure just filter those out
            // who - for whatever reason - might be new ones.
            .filter((change) => !change.isNewFile || change.fileName === oldPath)
            // The language service might want to do edits to the old path, not the new path -> rewire it.
            // If there is a better solution for this, please file a PR :)
            .map((change) => {
            change.fileName = change.fileName.replace(oldPath, newPath);
            return change;
        });
        const docs = new Map();
        const documentChanges = await Promise.all(updateImportsChanges.map(async (change) => {
            let fragment = docs.get(change.fileName);
            if (!fragment) {
                fragment = await this.getSnapshot(change.fileName).getFragment();
                docs.set(change.fileName, fragment);
            }
            return vscode_languageserver_1.TextDocumentEdit.create(vscode_languageserver_1.VersionedTextDocumentIdentifier.create(fragment.getURL(), 0), change.textChanges.map((edit) => {
                const range = documents_1.mapRangeToOriginal(fragment, utils_2.convertRange(fragment, edit.span));
                return vscode_languageserver_1.TextEdit.replace(range, edit.newText);
            }));
        }));
        return { documentChanges };
    }
    getLSForPath(path) {
        return this.lsAndTsDocResolver.getLSForPath(path);
    }
    getSnapshot(filePath, document) {
        return this.lsAndTsDocResolver.getSnapshot(filePath, document);
    }
}
exports.UpdateImportsProviderImpl = UpdateImportsProviderImpl;
//# sourceMappingURL=UpdateImportsProvider.js.map