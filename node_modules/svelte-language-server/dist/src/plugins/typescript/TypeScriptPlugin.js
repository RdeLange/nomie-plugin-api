"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptPlugin = void 0;
const typescript_1 = __importDefault(require("typescript"));
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../lib/documents");
const utils_1 = require("../../utils");
const CodeActionsProvider_1 = require("./features/CodeActionsProvider");
const CompletionProvider_1 = require("./features/CompletionProvider");
const DiagnosticsProvider_1 = require("./features/DiagnosticsProvider");
const HoverProvider_1 = require("./features/HoverProvider");
const RenameProvider_1 = require("./features/RenameProvider");
const UpdateImportsProvider_1 = require("./features/UpdateImportsProvider");
const LSAndTSDocResolver_1 = require("./LSAndTSDocResolver");
const utils_2 = require("./utils");
const getDirectiveCommentCompletions_1 = require("./features/getDirectiveCommentCompletions");
const FindReferencesProvider_1 = require("./features/FindReferencesProvider");
const SelectionRangeProvider_1 = require("./features/SelectionRangeProvider");
const SignatureHelpProvider_1 = require("./features/SignatureHelpProvider");
const SemanticTokensProvider_1 = require("./features/SemanticTokensProvider");
class TypeScriptPlugin {
    constructor(docManager, configManager, workspaceUris, isEditor = true) {
        this.configManager = configManager;
        this.lsAndTsDocResolver = new LSAndTSDocResolver_1.LSAndTSDocResolver(docManager, workspaceUris, configManager, 
        /**transformOnTemplateError */ isEditor);
        this.completionProvider = new CompletionProvider_1.CompletionsProviderImpl(this.lsAndTsDocResolver);
        this.codeActionsProvider = new CodeActionsProvider_1.CodeActionsProviderImpl(this.lsAndTsDocResolver, this.completionProvider);
        this.updateImportsProvider = new UpdateImportsProvider_1.UpdateImportsProviderImpl(this.lsAndTsDocResolver);
        this.diagnosticsProvider = new DiagnosticsProvider_1.DiagnosticsProviderImpl(this.lsAndTsDocResolver);
        this.renameProvider = new RenameProvider_1.RenameProviderImpl(this.lsAndTsDocResolver);
        this.hoverProvider = new HoverProvider_1.HoverProviderImpl(this.lsAndTsDocResolver);
        this.findReferencesProvider = new FindReferencesProvider_1.FindReferencesProviderImpl(this.lsAndTsDocResolver);
        this.selectionRangeProvider = new SelectionRangeProvider_1.SelectionRangeProviderImpl(this.lsAndTsDocResolver);
        this.signatureHelpProvider = new SignatureHelpProvider_1.SignatureHelpProviderImpl(this.lsAndTsDocResolver);
        this.semanticTokensProvider = new SemanticTokensProvider_1.SemanticTokensProviderImpl(this.lsAndTsDocResolver);
    }
    async getDiagnostics(document) {
        if (!this.featureEnabled('diagnostics')) {
            return [];
        }
        return this.diagnosticsProvider.getDiagnostics(document);
    }
    async doHover(document, position) {
        if (!this.featureEnabled('hover')) {
            return null;
        }
        return this.hoverProvider.doHover(document, position);
    }
    async getDocumentSymbols(document) {
        if (!this.featureEnabled('documentSymbols')) {
            return [];
        }
        const { lang, tsDoc } = this.getLSAndTSDoc(document);
        const fragment = await tsDoc.getFragment();
        const navTree = lang.getNavigationTree(tsDoc.filePath);
        const symbols = [];
        collectSymbols(navTree, undefined, (symbol) => symbols.push(symbol));
        const topContainerName = symbols[0].name;
        return (symbols
            .slice(1)
            .map((symbol) => {
            if (symbol.containerName === topContainerName) {
                return { ...symbol, containerName: 'script' };
            }
            return symbol;
        })
            .map((symbol) => documents_1.mapSymbolInformationToOriginal(fragment, symbol))
            // Due to svelte2tsx, there will also be some symbols that are unmapped.
            // Filter those out to keep the lsp from throwing errors.
            // Also filter out transformation artifacts
            .filter((symbol) => symbol.location.range.start.line >= 0 &&
            symbol.location.range.end.line >= 0 &&
            !symbol.name.startsWith('__sveltets_'))
            .map((symbol) => {
            if (symbol.name !== '<function>') {
                return symbol;
            }
            let name = documents_1.getTextInRange(symbol.location.range, document.getText()).trimLeft();
            if (name.length > 50) {
                name = name.substring(0, 50) + '...';
            }
            return {
                ...symbol,
                name
            };
        }));
        function collectSymbols(tree, container, cb) {
            const start = tree.spans[0];
            const end = tree.spans[tree.spans.length - 1];
            if (start && end) {
                cb(vscode_languageserver_1.SymbolInformation.create(tree.text, utils_2.symbolKindFromString(tree.kind), vscode_languageserver_1.Range.create(fragment.positionAt(start.start), fragment.positionAt(end.start + end.length)), fragment.getURL(), container));
            }
            if (tree.childItems) {
                for (const child of tree.childItems) {
                    collectSymbols(child, tree.text, cb);
                }
            }
        }
    }
    async getCompletions(document, position, completionContext) {
        if (!this.featureEnabled('completions')) {
            return null;
        }
        const tsDirectiveCommentCompletions = getDirectiveCommentCompletions_1.getDirectiveCommentCompletions(position, document, completionContext);
        const completions = await this.completionProvider.getCompletions(document, position, completionContext);
        if (completions && tsDirectiveCommentCompletions) {
            return vscode_languageserver_1.CompletionList.create(completions.items.concat(tsDirectiveCommentCompletions.items), completions.isIncomplete);
        }
        return completions !== null && completions !== void 0 ? completions : tsDirectiveCommentCompletions;
    }
    async resolveCompletion(document, completionItem) {
        return this.completionProvider.resolveCompletion(document, completionItem);
    }
    async getDefinitions(document, position) {
        if (!this.featureEnabled('definitions')) {
            return [];
        }
        const { lang, tsDoc } = this.getLSAndTSDoc(document);
        const fragment = await tsDoc.getFragment();
        const defs = lang.getDefinitionAndBoundSpan(tsDoc.filePath, fragment.offsetAt(fragment.getGeneratedPosition(position)));
        if (!defs || !defs.definitions) {
            return [];
        }
        const docs = new Map([[tsDoc.filePath, fragment]]);
        return await Promise.all(defs.definitions.map(async (def) => {
            let defDoc = docs.get(def.fileName);
            if (!defDoc) {
                defDoc = await this.getSnapshot(def.fileName).getFragment();
                docs.set(def.fileName, defDoc);
            }
            return vscode_languageserver_1.LocationLink.create(utils_1.pathToUrl(def.fileName), utils_2.convertToLocationRange(defDoc, def.textSpan), utils_2.convertToLocationRange(defDoc, def.textSpan), utils_2.convertToLocationRange(fragment, defs.textSpan));
        }));
    }
    async prepareRename(document, position) {
        if (!this.featureEnabled('rename')) {
            return null;
        }
        return this.renameProvider.prepareRename(document, position);
    }
    async rename(document, position, newName) {
        if (!this.featureEnabled('rename')) {
            return null;
        }
        return this.renameProvider.rename(document, position, newName);
    }
    async getCodeActions(document, range, context) {
        if (!this.featureEnabled('codeActions')) {
            return [];
        }
        return this.codeActionsProvider.getCodeActions(document, range, context);
    }
    async executeCommand(document, command, args) {
        if (!this.featureEnabled('codeActions')) {
            return null;
        }
        return this.codeActionsProvider.executeCommand(document, command, args);
    }
    async updateImports(fileRename) {
        if (!(this.configManager.enabled('svelte.enable') &&
            this.configManager.enabled('svelte.rename.enable'))) {
            return null;
        }
        return this.updateImportsProvider.updateImports(fileRename);
    }
    async findReferences(document, position, context) {
        if (!this.featureEnabled('findReferences')) {
            return null;
        }
        return this.findReferencesProvider.findReferences(document, position, context);
    }
    onWatchFileChanges(onWatchFileChangesParas) {
        const doneUpdateProjectFiles = new Set();
        for (const { fileName, changeType } of onWatchFileChangesParas) {
            const scriptKind = utils_2.getScriptKindFromFileName(fileName);
            if (scriptKind === typescript_1.default.ScriptKind.Unknown) {
                // We don't deal with svelte files here
                continue;
            }
            const snapshotManager = this.getSnapshotManager(fileName);
            if (changeType === vscode_languageserver_1.FileChangeType.Created) {
                if (!doneUpdateProjectFiles.has(snapshotManager)) {
                    snapshotManager.updateProjectFiles();
                    doneUpdateProjectFiles.add(snapshotManager);
                }
            }
            else if (changeType === vscode_languageserver_1.FileChangeType.Deleted) {
                snapshotManager.delete(fileName);
                return;
            }
            // Since the options parameter only applies to svelte snapshots, and this is not
            // a svelte file, we can just set it to false without having any effect.
            snapshotManager.updateByFileName(fileName, {
                strictMode: false,
                transformOnTemplateError: false
            });
        }
    }
    updateTsOrJsFile(fileName, changes) {
        const snapshotManager = this.getSnapshotManager(fileName);
        snapshotManager.updateTsOrJsFile(fileName, changes);
    }
    async getSelectionRange(document, position) {
        if (!this.featureEnabled('selectionRange')) {
            return null;
        }
        return this.selectionRangeProvider.getSelectionRange(document, position);
    }
    async getSignatureHelp(document, position, context) {
        if (!this.featureEnabled('signatureHelp')) {
            return null;
        }
        return this.signatureHelpProvider.getSignatureHelp(document, position, context);
    }
    async getSemanticTokens(textDocument, range) {
        if (!this.featureEnabled('semanticTokens')) {
            return {
                data: []
            };
        }
        return this.semanticTokensProvider.getSemanticTokens(textDocument, range);
    }
    getLSAndTSDoc(document) {
        return this.lsAndTsDocResolver.getLSAndTSDoc(document);
    }
    getSnapshot(filePath, document) {
        return this.lsAndTsDocResolver.getSnapshot(filePath, document);
    }
    /**
     *
     * @internal
     */
    getSnapshotManager(fileName) {
        return this.lsAndTsDocResolver.getSnapshotManager(fileName);
    }
    featureEnabled(feature) {
        return (this.configManager.enabled('typescript.enable') &&
            this.configManager.enabled(`typescript.${feature}.enable`));
    }
}
exports.TypeScriptPlugin = TypeScriptPlugin;
//# sourceMappingURL=TypeScriptPlugin.js.map