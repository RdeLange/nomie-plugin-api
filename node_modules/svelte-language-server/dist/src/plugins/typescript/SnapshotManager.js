"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapshotManager = void 0;
const typescript_1 = __importDefault(require("typescript"));
const DocumentSnapshot_1 = require("./DocumentSnapshot");
const logger_1 = require("../../logger");
class SnapshotManager {
    constructor(projectFiles, fileSpec, workspaceRoot) {
        this.projectFiles = projectFiles;
        this.fileSpec = fileSpec;
        this.workspaceRoot = workspaceRoot;
        this.documents = new Map();
        this.lastLogged = new Date(new Date().getTime() - 60001);
        this.watchExtensions = [
            typescript_1.default.Extension.Dts,
            typescript_1.default.Extension.Js,
            typescript_1.default.Extension.Jsx,
            typescript_1.default.Extension.Ts,
            typescript_1.default.Extension.Tsx,
            typescript_1.default.Extension.Json
        ];
    }
    updateProjectFiles() {
        const { include, exclude } = this.fileSpec;
        // Since we default to not include anything,
        //  just don't waste time on this
        if ((include === null || include === void 0 ? void 0 : include.length) === 0) {
            return;
        }
        const projectFiles = typescript_1.default.sys.readDirectory(this.workspaceRoot, this.watchExtensions, exclude, include);
        this.projectFiles = Array.from(new Set([...this.projectFiles, ...projectFiles]));
    }
    updateByFileName(fileName, options) {
        if (!this.has(fileName)) {
            return;
        }
        const newSnapshot = DocumentSnapshot_1.DocumentSnapshot.fromFilePath(fileName, options);
        const previousSnapshot = this.get(fileName);
        if (previousSnapshot) {
            newSnapshot.version = previousSnapshot.version + 1;
        }
        else {
            // ensure it's greater than initial version
            // so that ts server picks up the change
            newSnapshot.version += 1;
        }
        this.set(fileName, newSnapshot);
    }
    updateTsOrJsFile(fileName, changes) {
        if (!this.has(fileName)) {
            return;
        }
        const previousSnapshot = this.get(fileName);
        if (!(previousSnapshot instanceof DocumentSnapshot_1.JSOrTSDocumentSnapshot)) {
            return;
        }
        previousSnapshot.update(changes);
    }
    has(fileName) {
        return this.projectFiles.includes(fileName) || this.getFileNames().includes(fileName);
    }
    set(fileName, snapshot) {
        const prev = this.get(fileName);
        if (prev) {
            prev.destroyFragment();
        }
        this.logStatistics();
        return this.documents.set(fileName, snapshot);
    }
    get(fileName) {
        return this.documents.get(fileName);
    }
    delete(fileName) {
        this.projectFiles = this.projectFiles.filter((s) => s !== fileName);
        return this.documents.delete(fileName);
    }
    getFileNames() {
        return Array.from(this.documents.keys());
    }
    getProjectFileNames() {
        return [...this.projectFiles];
    }
    logStatistics() {
        const date = new Date();
        // Don't use setInterval because that will keep tests running forever
        if (date.getTime() - this.lastLogged.getTime() > 60000) {
            this.lastLogged = date;
            const projectFiles = this.getProjectFileNames();
            const allFiles = Array.from(new Set([...projectFiles, ...this.getFileNames()]));
            logger_1.Logger.log('SnapshotManager File Statistics:\n' +
                `Project files: ${projectFiles.length}\n` +
                `Svelte files: ${allFiles.filter((name) => name.endsWith('.svelte')).length}\n` +
                `From node_modules: ${allFiles.filter((name) => name.includes('node_modules')).length}\n` +
                `Total: ${allFiles.length}`);
        }
    }
}
exports.SnapshotManager = SnapshotManager;
//# sourceMappingURL=SnapshotManager.js.map