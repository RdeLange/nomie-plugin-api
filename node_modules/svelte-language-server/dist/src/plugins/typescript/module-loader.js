"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSvelteModuleLoader = void 0;
const typescript_1 = __importDefault(require("typescript"));
const utils_1 = require("./utils");
const path_1 = require("path");
const svelte_sys_1 = require("./svelte-sys");
/**
 * Caches resolved modules.
 */
class ModuleResolutionCache {
    constructor() {
        this.cache = new Map();
    }
    /**
     * Tries to get a cached module.
     */
    get(moduleName, containingFile) {
        return this.cache.get(this.getKey(moduleName, containingFile));
    }
    /**
     * Caches resolved module, if it is not undefined.
     */
    set(moduleName, containingFile, resolvedModule) {
        if (!resolvedModule) {
            return;
        }
        this.cache.set(this.getKey(moduleName, containingFile), resolvedModule);
    }
    /**
     * Deletes module from cache. Call this if a file was deleted.
     * @param resolvedModuleName full path of the module
     */
    delete(resolvedModuleName) {
        this.cache.forEach((val, key) => {
            if (val.resolvedFileName === resolvedModuleName) {
                this.cache.delete(key);
            }
        });
    }
    getKey(moduleName, containingFile) {
        return containingFile + ':::' + utils_1.ensureRealSvelteFilePath(moduleName);
    }
}
/**
 * Creates a module loader specifically for `.svelte` files.
 *
 * The typescript language service tries to look up other files that are referenced in the currently open svelte file.
 * For `.ts`/`.js` files this works, for `.svelte` files it does not by default.
 * Reason: The typescript language service does not know about the `.svelte` file ending,
 * so it assumes it's a normal typescript file and searches for files like `../Component.svelte.ts`, which is wrong.
 * In order to fix this, we need to wrap typescript's module resolution and reroute all `.svelte.ts` file lookups to .svelte.
 *
 * @param getSnapshot A function which returns a (in case of svelte file fully preprocessed) typescript/javascript snapshot
 * @param compilerOptions The typescript compiler options
 */
function createSvelteModuleLoader(getSnapshot, compilerOptions) {
    const svelteSys = svelte_sys_1.createSvelteSys(getSnapshot);
    const moduleCache = new ModuleResolutionCache();
    const pathAliases = getPathAliases(compilerOptions.paths);
    return {
        fileExists: svelteSys.fileExists,
        readFile: svelteSys.readFile,
        readDirectory: svelteSys.readDirectory,
        deleteFromModuleCache: (path) => moduleCache.delete(path),
        resolveModuleNames
    };
    function resolveModuleNames(moduleNames, containingFile) {
        return moduleNames.map((moduleName) => {
            const cachedModule = moduleCache.get(moduleName, containingFile);
            if (cachedModule) {
                return cachedModule;
            }
            const resolvedModule = resolveModuleName(moduleName, containingFile);
            moduleCache.set(moduleName, containingFile, resolvedModule);
            return resolvedModule;
        });
    }
    function resolveModuleName(name, containingFile) {
        // In the normal case, delegate to ts.resolveModuleName.
        // In the relative-imported.svelte case, delegate to our own svelte module loader.
        if (isAbsolutePath(name) || !utils_1.isSvelteFilePath(name)) {
            return typescript_1.default.resolveModuleName(name, containingFile, compilerOptions, typescript_1.default.sys)
                .resolvedModule;
        }
        const tsResolvedModule = typescript_1.default.resolveModuleName(name, containingFile, compilerOptions, svelteSys).resolvedModule;
        if (!tsResolvedModule || !utils_1.isVirtualSvelteFilePath(tsResolvedModule.resolvedFileName)) {
            return tsResolvedModule;
        }
        const resolvedFileName = utils_1.ensureRealSvelteFilePath(tsResolvedModule.resolvedFileName);
        const snapshot = getSnapshot(resolvedFileName);
        const resolvedSvelteModule = {
            extension: utils_1.getExtensionFromScriptKind(snapshot && snapshot.scriptKind),
            resolvedFileName
        };
        return resolvedSvelteModule;
    }
    function isAbsolutePath(path) {
        return path_1.isAbsolute(path) && !pathAliases.some((p) => path.startsWith(p));
    }
    function getPathAliases(paths) {
        return Object.keys(paths || {}).map((key) => {
            if (key.endsWith('*')) {
                key = key.substr(0, key.length - 1);
            }
            return key;
        });
    }
}
exports.createSvelteModuleLoader = createSvelteModuleLoader;
//# sourceMappingURL=module-loader.js.map