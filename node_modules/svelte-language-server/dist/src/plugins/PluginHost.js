"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginHost = void 0;
const lodash_1 = require("lodash");
const vscode_languageserver_1 = require("vscode-languageserver");
const logger_1 = require("../logger");
const utils_1 = require("../utils");
var ExecuteMode;
(function (ExecuteMode) {
    ExecuteMode[ExecuteMode["None"] = 0] = "None";
    ExecuteMode[ExecuteMode["FirstNonNull"] = 1] = "FirstNonNull";
    ExecuteMode[ExecuteMode["Collect"] = 2] = "Collect";
})(ExecuteMode || (ExecuteMode = {}));
class PluginHost {
    constructor(documentsManager) {
        this.documentsManager = documentsManager;
        this.plugins = [];
        this.pluginHostConfig = {
            filterIncompleteCompletions: true,
            definitionLinkSupport: false
        };
    }
    initialize(pluginHostConfig) {
        this.pluginHostConfig = pluginHostConfig;
    }
    register(plugin) {
        this.plugins.push(plugin);
    }
    async getDiagnostics(textDocument) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getDiagnostics', [document], ExecuteMode.Collect));
    }
    async doHover(textDocument, position) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return this.execute('doHover', [document, position], ExecuteMode.FirstNonNull);
    }
    async getCompletions(textDocument, position, completionContext) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        const completions = (await this.execute('getCompletions', [document, position, completionContext], ExecuteMode.Collect)).filter((completion) => completion != null);
        let flattenedCompletions = lodash_1.flatten(completions.map((completion) => completion.items));
        const isIncomplete = completions.reduce((incomplete, completion) => incomplete || completion.isIncomplete, false);
        // If the result is incomplete, we need to filter the results ourselves
        // to throw out non-matching results. VSCode does filter client-side,
        // but other IDEs might not.
        if (isIncomplete && this.pluginHostConfig.filterIncompleteCompletions) {
            const offset = document.offsetAt(position);
            // Assumption for performance reasons:
            // Noone types import names longer than 20 characters and still expects perfect autocompletion.
            const text = document.getText().substring(Math.max(0, offset - 20), offset);
            const start = utils_1.regexLastIndexOf(text, /[\W\s]/g) + 1;
            const filterValue = text.substring(start).toLowerCase();
            flattenedCompletions = flattenedCompletions.filter((comp) => comp.label.toLowerCase().includes(filterValue));
        }
        return vscode_languageserver_1.CompletionList.create(flattenedCompletions, isIncomplete);
    }
    async resolveCompletion(textDocument, completionItem) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        const result = await this.execute('resolveCompletion', [document, completionItem], ExecuteMode.FirstNonNull);
        return result !== null && result !== void 0 ? result : completionItem;
    }
    async formatDocument(textDocument, options) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('formatDocument', [document, options], ExecuteMode.Collect));
    }
    async doTagComplete(textDocument, position) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return this.execute('doTagComplete', [document, position], ExecuteMode.FirstNonNull);
    }
    async getDocumentColors(textDocument) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getDocumentColors', [document], ExecuteMode.Collect));
    }
    async getColorPresentations(textDocument, range, color) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getColorPresentations', [document, range, color], ExecuteMode.Collect));
    }
    async getDocumentSymbols(textDocument) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getDocumentSymbols', [document], ExecuteMode.Collect));
    }
    async getDefinitions(textDocument, position) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        const definitions = lodash_1.flatten(await this.execute('getDefinitions', [document, position], ExecuteMode.Collect));
        if (this.pluginHostConfig.definitionLinkSupport) {
            return definitions;
        }
        else {
            return definitions.map((def) => ({ range: def.targetSelectionRange, uri: def.targetUri }));
        }
    }
    async getCodeActions(textDocument, range, context) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getCodeActions', [document, range, context], ExecuteMode.Collect));
    }
    async executeCommand(textDocument, command, args) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return await this.execute('executeCommand', [document, command, args], ExecuteMode.FirstNonNull);
    }
    async updateImports(fileRename) {
        return await this.execute('updateImports', [fileRename], ExecuteMode.FirstNonNull);
    }
    async prepareRename(textDocument, position) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return await this.execute('prepareRename', [document, position], ExecuteMode.FirstNonNull);
    }
    async rename(textDocument, position, newName) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return await this.execute('rename', [document, position, newName], ExecuteMode.FirstNonNull);
    }
    async findReferences(textDocument, position, context) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return await this.execute('findReferences', [document, position, context], ExecuteMode.FirstNonNull);
    }
    async getSignatureHelp(textDocument, position, context) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return await this.execute('getSignatureHelp', [document, position, context], ExecuteMode.FirstNonNull);
    }
    /**
     * The selection range supports multiple cursors,
     * each position should return its own selection range tree like `Array.map`.
     * Quote the LSP spec
     * > A selection range in the return array is for the position in the provided parameters at the same index. Therefore positions[i] must be contained in result[i].range.
     * @see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_selectionRange
     *
     * Making PluginHost implement the same interface would make it quite hard to get
     * the corresponding selection range of each position from different plugins.
     * Therefore the special treatment here.
     */
    async getSelectionRanges(textDocument, positions) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        try {
            return Promise.all(positions.map(async (position) => {
                var _a;
                for (const plugin of this.plugins) {
                    const range = await ((_a = plugin.getSelectionRange) === null || _a === void 0 ? void 0 : _a.call(plugin, document, position));
                    if (range) {
                        return range;
                    }
                }
                return vscode_languageserver_1.SelectionRange.create(vscode_languageserver_1.Range.create(position, position));
            }));
        }
        catch (error) {
            logger_1.Logger.error(error);
            return null;
        }
    }
    async getSemanticTokens(textDocument, range) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return await this.execute('getSemanticTokens', [document, range], ExecuteMode.FirstNonNull);
    }
    onWatchFileChanges(onWatchFileChangesParas) {
        var _a;
        for (const support of this.plugins) {
            (_a = support.onWatchFileChanges) === null || _a === void 0 ? void 0 : _a.call(support, onWatchFileChangesParas);
        }
    }
    updateTsOrJsFile(fileName, changes) {
        var _a;
        for (const support of this.plugins) {
            (_a = support.updateTsOrJsFile) === null || _a === void 0 ? void 0 : _a.call(support, fileName, changes);
        }
    }
    getDocument(uri) {
        return this.documentsManager.get(uri);
    }
    async execute(name, args, mode) {
        const plugins = this.plugins.filter((plugin) => typeof plugin[name] === 'function');
        switch (mode) {
            case ExecuteMode.FirstNonNull:
                for (const plugin of plugins) {
                    const res = await this.tryExecutePlugin(plugin, name, args, null);
                    if (res != null) {
                        return res;
                    }
                }
                return null;
            case ExecuteMode.Collect:
                return Promise.all(plugins.map((plugin) => this.tryExecutePlugin(plugin, name, args, [])));
            case ExecuteMode.None:
                await Promise.all(plugins.map((plugin) => this.tryExecutePlugin(plugin, name, args, null)));
                return;
        }
    }
    async tryExecutePlugin(plugin, fnName, args, failValue) {
        try {
            return await plugin[fnName](...args);
        }
        catch (e) {
            logger_1.Logger.error(e);
            return failValue;
        }
    }
}
exports.PluginHost = PluginHost;
//# sourceMappingURL=PluginHost.js.map