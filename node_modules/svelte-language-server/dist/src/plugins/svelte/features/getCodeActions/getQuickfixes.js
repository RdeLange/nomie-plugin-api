"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isIgnorableSvelteDiagnostic = exports.getQuickfixActions = void 0;
const estree_walker_1 = require("estree-walker");
const os_1 = require("os");
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../../../lib/documents");
const utils_1 = require("../../../../utils");
/**
 * Get applicable quick fixes.
 */
async function getQuickfixActions(svelteDoc, svelteDiagnostics) {
    const { ast } = await svelteDoc.getCompiled();
    return Promise.all(svelteDiagnostics.map(async (diagnostic) => await createQuickfixAction(diagnostic, svelteDoc, ast)));
}
exports.getQuickfixActions = getQuickfixActions;
async function createQuickfixAction(diagnostic, svelteDoc, ast) {
    const textDocument = vscode_languageserver_1.VersionedTextDocumentIdentifier.create(utils_1.pathToUrl(svelteDoc.getFilePath()), svelteDoc.version);
    return vscode_languageserver_1.CodeAction.create(getCodeActionTitle(diagnostic), {
        documentChanges: [
            vscode_languageserver_1.TextDocumentEdit.create(textDocument, [
                await getSvelteIgnoreEdit(svelteDoc, ast, diagnostic)
            ])
        ]
    }, vscode_languageserver_1.CodeActionKind.QuickFix);
}
function getCodeActionTitle(diagnostic) {
    // make it distinguishable with eslint's code action
    return `(svelte) Disable ${diagnostic.code} for this line`;
}
/**
 * Whether or not the given diagnostic can be ignored via a
 * <!-- svelte-ignore <code> -->
 */
function isIgnorableSvelteDiagnostic(diagnostic) {
    const { source, severity, code } = diagnostic;
    return (code &&
        !nonIgnorableWarnings.includes(code) &&
        source === 'svelte' &&
        severity !== vscode_languageserver_1.DiagnosticSeverity.Error);
}
exports.isIgnorableSvelteDiagnostic = isIgnorableSvelteDiagnostic;
const nonIgnorableWarnings = [
    'missing-custom-element-compile-options',
    'unused-export-let',
    'css-unused-selector'
];
async function getSvelteIgnoreEdit(svelteDoc, ast, diagnostic) {
    var _a, _b;
    const { code, range: { start, end } } = diagnostic;
    const transpiled = await svelteDoc.getTranspiled();
    const content = transpiled.getText();
    const { html } = ast;
    const generatedStart = transpiled.getGeneratedPosition(start);
    const generatedEnd = transpiled.getGeneratedPosition(end);
    const diagnosticStartOffset = documents_1.offsetAt(generatedStart, transpiled.getText());
    const diagnosticEndOffset = documents_1.offsetAt(generatedEnd, transpiled.getText());
    const offsetRange = {
        pos: diagnosticStartOffset,
        end: diagnosticEndOffset
    };
    const node = findTagForRange(html, offsetRange);
    const nodeStartPosition = documents_1.positionAt(node.start, content);
    const nodeLineStart = documents_1.offsetAt({
        line: nodeStartPosition.line,
        character: 0
    }, transpiled.getText());
    const afterStartLineStart = content.slice(nodeLineStart);
    const indent = (_b = (_a = /^[ |\t]+/.exec(afterStartLineStart)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : '';
    // TODO: Make all code action's new line consistent
    const ignore = `${indent}<!-- svelte-ignore ${code} -->${os_1.EOL}`;
    const position = vscode_languageserver_1.Position.create(nodeStartPosition.line, 0);
    return documents_1.mapObjWithRangeToOriginal(transpiled, vscode_languageserver_1.TextEdit.insert(position, ignore));
}
const elementOrComponent = ['Component', 'Element', 'InlineComponent'];
function findTagForRange(html, range) {
    let nearest = html;
    estree_walker_1.walk(html, {
        enter(node, parent) {
            const { type } = node;
            const isBlock = 'block' in node || node.type.toLowerCase().includes('block');
            const isFragment = type === 'Fragment';
            const keepLooking = isFragment || elementOrComponent.includes(type) || isBlock;
            if (!keepLooking) {
                this.skip();
                return;
            }
            if (within(node, range) && parent === nearest) {
                nearest = node;
            }
        }
    });
    return nearest;
}
function within(node, range) {
    return node.end >= range.end && node.start <= range.pos;
}
//# sourceMappingURL=getQuickfixes.js.map