"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompletionsProviderImpl = void 0;
const typescript_1 = __importDefault(require("typescript"));
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../../lib/documents");
const utils_1 = require("../../../utils");
const previewer_1 = require("../previewer");
const utils_2 = require("../utils");
const getJsDocTemplateCompletion_1 = require("./getJsDocTemplateCompletion");
const utils_3 = require("./utils");
class CompletionsProviderImpl {
    constructor(lsAndTsDocResolver) {
        this.lsAndTsDocResolver = lsAndTsDocResolver;
        /**
         * The language service throws an error if the character is not a valid trigger character.
         * Also, the completions are worse.
         * Therefore, only use the characters the typescript compiler treats as valid.
         */
        this.validTriggerCharacters = ['.', '"', "'", '`', '/', '@', '<', '#'];
    }
    isValidTriggerCharacter(character) {
        return this.validTriggerCharacters.includes(character);
    }
    async getCompletions(document, position, completionContext) {
        var _a;
        if (documents_1.isInTag(position, document.styleInfo)) {
            return null;
        }
        const { lang, tsDoc, userPreferences } = this.lsAndTsDocResolver.getLSAndTSDoc(document);
        const filePath = tsDoc.filePath;
        if (!filePath) {
            return null;
        }
        const triggerCharacter = completionContext === null || completionContext === void 0 ? void 0 : completionContext.triggerCharacter;
        const triggerKind = completionContext === null || completionContext === void 0 ? void 0 : completionContext.triggerKind;
        const validTriggerCharacter = this.isValidTriggerCharacter(triggerCharacter)
            ? triggerCharacter
            : undefined;
        const isCustomTriggerCharacter = triggerKind === vscode_languageserver_1.CompletionTriggerKind.TriggerCharacter;
        const isJsDocTriggerCharacter = triggerCharacter === '*';
        const isEventTriggerCharacter = triggerCharacter === ':';
        // ignore any custom trigger character specified in server capabilities
        //  and is not allow by ts
        if (isCustomTriggerCharacter &&
            !validTriggerCharacter &&
            !isJsDocTriggerCharacter &&
            !isEventTriggerCharacter) {
            return null;
        }
        const fragment = await tsDoc.getFragment();
        if (!fragment.isInGenerated(position)) {
            return null;
        }
        const offset = fragment.offsetAt(fragment.getGeneratedPosition(position));
        if (isJsDocTriggerCharacter) {
            return getJsDocTemplateCompletion_1.getJsDocTemplateCompletion(fragment, lang, filePath, offset);
        }
        const eventCompletions = this.getEventCompletions(lang, document, tsDoc, fragment, position);
        if (isEventTriggerCharacter) {
            return vscode_languageserver_1.CompletionList.create(eventCompletions, !!tsDoc.parserError);
        }
        const completions = ((_a = lang.getCompletionsAtPosition(filePath, offset, {
            ...userPreferences,
            triggerCharacter: validTriggerCharacter
        })) === null || _a === void 0 ? void 0 : _a.entries) || [];
        if (completions.length === 0 && eventCompletions.length === 0) {
            return tsDoc.parserError ? vscode_languageserver_1.CompletionList.create([], true) : null;
        }
        const existingImports = this.getExistingImports(document);
        const completionItems = completions
            .map((comp) => this.toCompletionItem(fragment, comp, utils_1.pathToUrl(tsDoc.filePath), position, existingImports))
            .filter(utils_1.isNotNullOrUndefined)
            .map((comp) => documents_1.mapCompletionItemToOriginal(fragment, comp))
            .concat(eventCompletions);
        return vscode_languageserver_1.CompletionList.create(completionItems, !!tsDoc.parserError);
    }
    getExistingImports(document) {
        const rawImports = utils_1.getRegExpMatches(scriptImportRegex, document.getText()).map((match) => { var _a; return ((_a = match[1]) !== null && _a !== void 0 ? _a : match[2]).split(','); });
        const tidiedImports = utils_1.flatten(rawImports).map((match) => match.trim());
        return new Set(tidiedImports);
    }
    getEventCompletions(lang, doc, tsDoc, fragment, originalPosition) {
        const snapshot = utils_3.getComponentAtPosition(this.lsAndTsDocResolver, lang, doc, tsDoc, fragment, originalPosition);
        if (!snapshot) {
            return [];
        }
        const offset = doc.offsetAt(originalPosition);
        const { start, end } = documents_1.getWordRangeAt(doc.getText(), offset, {
            left: /\S+$/,
            right: /[^\w$:]/
        });
        return snapshot.getEvents().map((event) => {
            const eventName = 'on:' + event.name;
            return {
                label: eventName,
                sortText: '-1',
                detail: event.name + ': ' + event.type,
                documentation: event.doc && { kind: vscode_languageserver_1.MarkupKind.Markdown, value: event.doc },
                textEdit: start !== end
                    ? vscode_languageserver_1.TextEdit.replace(documents_1.toRange(doc.getText(), start, end), eventName)
                    : undefined
            };
        });
    }
    toCompletionItem(fragment, comp, uri, position, existingImports) {
        const completionLabelAndInsert = this.getCompletionLabelAndInsert(fragment, comp);
        if (!completionLabelAndInsert) {
            return null;
        }
        const { label, insertText, isSvelteComp } = completionLabelAndInsert;
        // TS may suggest another Svelte component even if there already exists an import
        // with the same name, because under the hood every Svelte component is postfixed
        // with `__SvelteComponent`. In this case, filter out this completion by returning null.
        if (isSvelteComp && existingImports.has(label)) {
            return null;
        }
        return {
            label,
            insertText,
            kind: utils_2.scriptElementKindToCompletionItemKind(comp.kind),
            commitCharacters: utils_2.getCommitCharactersForScriptElement(comp.kind),
            // Make sure svelte component takes precedence
            sortText: isSvelteComp ? '-1' : comp.sortText,
            preselect: isSvelteComp ? true : comp.isRecommended,
            // pass essential data for resolving completion
            data: {
                ...comp,
                uri,
                position
            }
        };
    }
    getCompletionLabelAndInsert(fragment, comp) {
        let { kind, kindModifiers, name, source } = comp;
        const isScriptElement = kind === typescript_1.default.ScriptElementKind.scriptElement;
        const hasModifier = Boolean(comp.kindModifiers);
        const isSvelteComp = this.isSvelteComponentImport(name);
        if (isSvelteComp) {
            name = this.changeSvelteComponentName(name);
            if (this.isExistingSvelteComponentImport(fragment, name, source)) {
                return null;
            }
        }
        if (isScriptElement && hasModifier) {
            return {
                insertText: name,
                label: name + kindModifiers,
                isSvelteComp
            };
        }
        return {
            label: name,
            isSvelteComp
        };
    }
    isExistingSvelteComponentImport(fragment, name, source) {
        const importStatement = new RegExp(`import ${name} from ["'\`][\\s\\S]+\\.svelte["'\`]`);
        return !!source && !!fragment.text.match(importStatement);
    }
    async resolveCompletion(document, completionItem) {
        const { data: comp } = completionItem;
        const { tsDoc, lang, userPreferences } = this.lsAndTsDocResolver.getLSAndTSDoc(document);
        const filePath = tsDoc.filePath;
        if (!comp || !filePath) {
            return completionItem;
        }
        const fragment = await tsDoc.getFragment();
        const detail = lang.getCompletionEntryDetails(filePath, fragment.offsetAt(fragment.getGeneratedPosition(comp.position)), comp.name, {}, comp.source, userPreferences);
        if (detail) {
            const { detail: itemDetail, documentation: itemDocumentation } = this.getCompletionDocument(detail);
            completionItem.detail = itemDetail;
            completionItem.documentation = itemDocumentation;
        }
        const actions = detail === null || detail === void 0 ? void 0 : detail.codeActions;
        const isImport = !!(detail === null || detail === void 0 ? void 0 : detail.source);
        if (actions) {
            const edit = [];
            for (const action of actions) {
                for (const change of action.changes) {
                    edit.push(...this.codeActionChangesToTextEdit(document, fragment, change, isImport, documents_1.isInTag(comp.position, document.scriptInfo) ||
                        documents_1.isInTag(comp.position, document.moduleScriptInfo)));
                }
            }
            completionItem.additionalTextEdits = edit;
        }
        return completionItem;
    }
    getCompletionDocument(compDetail) {
        const { source, documentation: tsDocumentation, displayParts, tags } = compDetail;
        let detail = this.changeSvelteComponentName(typescript_1.default.displayPartsToString(displayParts));
        if (source) {
            const importPath = typescript_1.default.displayPartsToString(source);
            detail = `Auto import from ${importPath}\n${detail}`;
        }
        const markdownDoc = previewer_1.getMarkdownDocumentation(tsDocumentation, tags);
        const documentation = markdownDoc
            ? { value: markdownDoc, kind: vscode_languageserver_1.MarkupKind.Markdown }
            : undefined;
        return {
            documentation,
            detail
        };
    }
    codeActionChangesToTextEdit(doc, fragment, changes, isImport, actionTriggeredInScript) {
        return changes.textChanges.map((change) => this.codeActionChangeToTextEdit(doc, fragment, change, isImport, actionTriggeredInScript));
    }
    codeActionChangeToTextEdit(doc, fragment, change, isImport, actionTriggeredInScript) {
        change.newText = this.changeComponentImport(change.newText, actionTriggeredInScript);
        const scriptTagInfo = fragment.scriptInfo;
        if (!scriptTagInfo) {
            // no script tag defined yet, add it.
            return vscode_languageserver_1.TextEdit.replace(beginOfDocumentRange, `<script>${typescript_1.default.sys.newLine}${change.newText}</script>${typescript_1.default.sys.newLine}`);
        }
        const { span } = change;
        const virtualRange = utils_2.convertRange(fragment, span);
        let range;
        const isNewImport = isImport && virtualRange.start.character === 0;
        // Since new import always can't be mapped, we'll have special treatment here
        //  but only hack this when there is multiple line in script
        if (isNewImport && virtualRange.start.line > 1) {
            range = this.mapRangeForNewImport(fragment, virtualRange);
        }
        else {
            range = documents_1.mapRangeToOriginal(fragment, virtualRange);
        }
        // If range is somehow not mapped in parent,
        // the import is mapped wrong or is outside script tag,
        // use script starting point instead.
        // This happens among other things if the completion is the first import of the file.
        if (range.start.line === -1 ||
            (range.start.line === 0 && range.start.character <= 1 && span.length === 0) ||
            !documents_1.isInTag(range.start, scriptTagInfo)) {
            range = utils_2.convertRange(doc, {
                start: scriptTagInfo.start,
                length: span.length
            });
        }
        // prevent newText from being placed like this: <script>import {} from ''
        if (doc.offsetAt(range.start) === scriptTagInfo.start &&
            !change.newText.startsWith('\r\n') &&
            !change.newText.startsWith('\n')) {
            change.newText = typescript_1.default.sys.newLine + change.newText;
        }
        return vscode_languageserver_1.TextEdit.replace(range, change.newText);
    }
    mapRangeForNewImport(fragment, virtualRange) {
        const sourceMappableRange = this.offsetLinesAndMovetoStartOfLine(virtualRange, -1);
        const mappableRange = documents_1.mapRangeToOriginal(fragment, sourceMappableRange);
        return this.offsetLinesAndMovetoStartOfLine(mappableRange, 1);
    }
    offsetLinesAndMovetoStartOfLine({ start, end }, offsetLines) {
        return vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(start.line + offsetLines, 0), vscode_languageserver_1.Position.create(end.line + offsetLines, 0));
    }
    isSvelteComponentImport(className) {
        return className.endsWith('__SvelteComponent_');
    }
    changeSvelteComponentName(name) {
        return name.replace(/(\w+)__SvelteComponent_/, '$1');
    }
    changeComponentImport(importText, actionTriggeredInScript) {
        const changedName = this.changeSvelteComponentName(importText);
        if (importText !== changedName || !actionTriggeredInScript) {
            // For some reason, TS sometimes adds the `type` modifier. Remove it
            // in case of Svelte component imports or if import triggered from markup.
            return changedName.replace(' type ', ' ');
        }
        return importText;
    }
}
exports.CompletionsProviderImpl = CompletionsProviderImpl;
const beginOfDocumentRange = vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(0, 0), vscode_languageserver_1.Position.create(0, 0));
// `import {...} from '..'` or `import ... from '..'`
// Note: Does not take into account if import is within a comment.
// eslint-disable-next-line max-len
const scriptImportRegex = /\bimport\s+{([^}]*?)}\s+?from\s+['"`].+?['"`]|\bimport\s+(\w+?)\s+from\s+['"`].+?['"`]/g;
//# sourceMappingURL=CompletionProvider.js.map