"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageService = exports.getService = exports.getLanguageServiceForDocument = exports.getLanguageServiceForPath = void 0;
const path_1 = require("path");
const typescript_1 = __importDefault(require("typescript"));
const logger_1 = require("../../logger");
const importPackage_1 = require("../../importPackage");
const DocumentSnapshot_1 = require("./DocumentSnapshot");
const module_loader_1 = require("./module-loader");
const SnapshotManager_1 = require("./SnapshotManager");
const utils_1 = require("./utils");
const services = new Map();
function getLanguageServiceForPath(path, workspaceUris, docContext) {
    return getService(path, workspaceUris, docContext).getService();
}
exports.getLanguageServiceForPath = getLanguageServiceForPath;
function getLanguageServiceForDocument(document, workspaceUris, docContext) {
    return getService(document.getFilePath() || '', workspaceUris, docContext).updateDocument(document);
}
exports.getLanguageServiceForDocument = getLanguageServiceForDocument;
function getService(path, workspaceUris, docContext) {
    const tsconfigPath = utils_1.findTsConfigPath(path, workspaceUris);
    let service;
    if (services.has(tsconfigPath)) {
        service = services.get(tsconfigPath);
    }
    else {
        logger_1.Logger.log('Initialize new ts service at ', tsconfigPath);
        service = createLanguageService(tsconfigPath, docContext);
        services.set(tsconfigPath, service);
    }
    return service;
}
exports.getService = getService;
function createLanguageService(tsconfigPath, docContext) {
    const workspacePath = tsconfigPath ? path_1.dirname(tsconfigPath) : '';
    const { options: compilerOptions, fileNames: files, raw } = getParsedConfig();
    // raw is the tsconfig merged with extending config
    // see: https://github.com/microsoft/TypeScript/blob/08e4f369fbb2a5f0c30dee973618d65e6f7f09f8/src/compiler/commandLineParser.ts#L2537
    const snapshotManager = new SnapshotManager_1.SnapshotManager(files, raw, workspacePath || process.cwd());
    const svelteModuleLoader = module_loader_1.createSvelteModuleLoader(getSnapshot, compilerOptions);
    let svelteTsPath;
    try {
        // For when svelte2tsx is part of node_modules, for example VS Code extension
        svelteTsPath = path_1.dirname(require.resolve('svelte2tsx'));
    }
    catch (e) {
        // Fall back to dirname, for example for svelte-check
        svelteTsPath = __dirname;
    }
    const svelteTsxFiles = [
        './svelte-shims.d.ts',
        './svelte-jsx.d.ts',
        './svelte-native-jsx.d.ts'
    ].map((f) => typescript_1.default.sys.resolvePath(path_1.resolve(svelteTsPath, f)));
    const host = {
        getCompilationSettings: () => compilerOptions,
        getScriptFileNames: () => Array.from(new Set([
            ...snapshotManager.getProjectFileNames(),
            ...snapshotManager.getFileNames(),
            ...svelteTsxFiles
        ])),
        getScriptVersion: (fileName) => getSnapshot(fileName).version.toString(),
        getScriptSnapshot: getSnapshot,
        getCurrentDirectory: () => workspacePath,
        getDefaultLibFileName: typescript_1.default.getDefaultLibFilePath,
        fileExists: svelteModuleLoader.fileExists,
        readFile: svelteModuleLoader.readFile,
        resolveModuleNames: svelteModuleLoader.resolveModuleNames,
        readDirectory: svelteModuleLoader.readDirectory,
        getDirectories: typescript_1.default.sys.getDirectories,
        // vscode's uri is all lowercase
        useCaseSensitiveFileNames: () => false,
        getScriptKind: (fileName) => getSnapshot(fileName).scriptKind
    };
    let languageService = typescript_1.default.createLanguageService(host);
    const transformationConfig = {
        strictMode: !!compilerOptions.strict,
        transformOnTemplateError: docContext.transformOnTemplateError
    };
    return {
        tsconfigPath,
        compilerOptions,
        getService: () => languageService,
        updateDocument,
        deleteDocument,
        snapshotManager
    };
    function deleteDocument(filePath) {
        svelteModuleLoader.deleteFromModuleCache(filePath);
        snapshotManager.delete(filePath);
    }
    function updateDocument(document) {
        const preSnapshot = snapshotManager.get(document.getFilePath());
        // Don't reinitialize document if no update needed.
        if ((preSnapshot === null || preSnapshot === void 0 ? void 0 : preSnapshot.version) === document.version) {
            return languageService;
        }
        const newSnapshot = DocumentSnapshot_1.DocumentSnapshot.fromDocument(document, transformationConfig);
        if (preSnapshot && preSnapshot.scriptKind !== newSnapshot.scriptKind) {
            // Restart language service as it doesn't handle script kind changes.
            languageService.dispose();
            languageService = typescript_1.default.createLanguageService(host);
        }
        snapshotManager.set(document.getFilePath(), newSnapshot);
        return languageService;
    }
    function getSnapshot(fileName) {
        fileName = utils_1.ensureRealSvelteFilePath(fileName);
        let doc = snapshotManager.get(fileName);
        if (doc) {
            return doc;
        }
        if (utils_1.isSvelteFilePath(fileName)) {
            const file = typescript_1.default.sys.readFile(fileName) || '';
            doc = DocumentSnapshot_1.DocumentSnapshot.fromDocument(docContext.createDocument(fileName, file), transformationConfig);
        }
        else {
            doc = DocumentSnapshot_1.DocumentSnapshot.fromFilePath(fileName, transformationConfig);
        }
        snapshotManager.set(fileName, doc);
        return doc;
    }
    function getParsedConfig() {
        const forcedCompilerOptions = {
            allowNonTsExtensions: true,
            target: typescript_1.default.ScriptTarget.Latest,
            module: typescript_1.default.ModuleKind.ESNext,
            moduleResolution: typescript_1.default.ModuleResolutionKind.NodeJs,
            allowJs: true,
            noEmit: true,
            declaration: false,
            skipLibCheck: true,
            // these are needed to handle the results of svelte2tsx preprocessing:
            jsx: typescript_1.default.JsxEmit.Preserve
        };
        // always let ts parse config to get default compilerOption
        let configJson = (tsconfigPath && typescript_1.default.readConfigFile(tsconfigPath, typescript_1.default.sys.readFile).config) ||
            getDefaultJsConfig();
        // Only default exclude when no extends for now
        if (!configJson.extends) {
            configJson = Object.assign({
                exclude: getDefaultExclude()
            }, configJson);
        }
        const parsedConfig = typescript_1.default.parseJsonConfigFileContent(configJson, typescript_1.default.sys, workspacePath, forcedCompilerOptions, tsconfigPath, undefined, [{ extension: 'svelte', isMixedContent: false, scriptKind: typescript_1.default.ScriptKind.TSX }]);
        const compilerOptions = {
            ...parsedConfig.options,
            ...forcedCompilerOptions
        };
        // detect which JSX namespace to use (svelte | svelteNative) if not specified or not compatible
        if (!compilerOptions.jsxFactory || !compilerOptions.jsxFactory.startsWith('svelte')) {
            //default to regular svelte, this causes the usage of the "svelte.JSX" namespace
            compilerOptions.jsxFactory = 'svelte.createElement';
            //override if we detect svelte-native
            if (workspacePath) {
                try {
                    const svelteNativePkgInfo = importPackage_1.getPackageInfo('svelte-native', workspacePath);
                    if (svelteNativePkgInfo.path) {
                        compilerOptions.jsxFactory = 'svelteNative.createElement';
                    }
                }
                catch (e) {
                    //we stay regular svelte
                }
            }
        }
        return {
            ...parsedConfig,
            options: compilerOptions
        };
    }
    /**
     * This should only be used when there's no jsconfig/tsconfig at all
     */
    function getDefaultJsConfig() {
        return {
            compilerOptions: {
                maxNodeModuleJsDepth: 2,
                allowSyntheticDefaultImports: true
            },
            // Necessary to not flood the initial files
            // with potentially completely unrelated .ts/.js files:
            include: []
        };
    }
    function getDefaultExclude() {
        return ['__sapper__', 'node_modules'];
    }
}
exports.createLanguageService = createLanguageService;
//# sourceMappingURL=service.js.map