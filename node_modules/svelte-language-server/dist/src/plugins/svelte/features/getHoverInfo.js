"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHoverInfo = void 0;
const SvelteTags_1 = require("./SvelteTags");
const utils_1 = require("../../../utils");
const documents_1 = require("../../../lib/documents");
/**
 * Get hover information for special svelte tags within moustache tags.
 */
function getHoverInfo(svelteDoc, position) {
    const offset = svelteDoc.offsetAt(position);
    const isInStyleOrScript = documents_1.isInTag(position, svelteDoc.style) ||
        documents_1.isInTag(position, svelteDoc.script) ||
        documents_1.isInTag(position, svelteDoc.moduleScript);
    const offsetStart = Math.max(offset - 10, 0);
    const charactersAroundOffset = svelteDoc
        .getText()
        // use last 10 and next 10 characters, should cover 99% of all cases
        .substr(offsetStart, 20);
    const isNoSvelteTag = !tagRegexp.test(charactersAroundOffset);
    if (isInStyleOrScript || isNoSvelteTag) {
        return null;
    }
    const tag = getTagAtOffset(svelteDoc, offsetStart, charactersAroundOffset, offset);
    if (!tag) {
        return null;
    }
    return { contents: SvelteTags_1.documentation[tag] };
}
exports.getHoverInfo = getHoverInfo;
/**
 * Get the tag that is at the offset.
 */
function getTagAtOffset(svelteDoc, charactersOffset, charactersAroundOffset, offset) {
    const foundTag = tagPossibilities.find((tagAndValues) => tagAndValues.values.find((value) => isAroundOffset(charactersOffset, charactersAroundOffset, value, offset)));
    if (!foundTag) {
        return null;
    }
    if (foundTag.tag !== ':else') {
        return foundTag.tag;
    }
    // ':else can be part of one of each, await, if --> find out which one
    return SvelteTags_1.getLatestOpeningTag(svelteDoc, offset);
}
function isAroundOffset(charactersOffset, charactersAroundOffset, toFind, offset) {
    const match = charactersAroundOffset.match(toFind);
    if (!match || match.index === undefined) {
        return false;
    }
    const idx = match.index + charactersOffset;
    return idx <= offset && idx + toFind.length >= offset;
}
const tagPossibilities = [
    { tag: 'if', values: ['#if', '/if', ':else if'] },
    // each
    { tag: 'each', values: ['#each', '/each'] },
    // await
    { tag: 'await', values: ['#await', '/await', ':then', ':catch'] },
    // key
    { tag: 'key', values: ['#key', '/key'] },
    // @
    { tag: 'html', values: ['@html'] },
    { tag: 'debug', values: ['@debug'] },
    // this tag has multiple possibilities
    { tag: ':else', values: [':else'] }
];
const tagRegexp = new RegExp(`[\\s\\S]*{\\s*(${utils_1.flatten(tagPossibilities.map((p) => p.values)).join('|')})(\\s|})`);
//# sourceMappingURL=getHoverInfo.js.map