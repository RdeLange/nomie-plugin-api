"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseHtml = void 0;
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
const utils_1 = require("./utils");
const parser = vscode_html_languageservice_1.getLanguageService();
/**
 * Parses text as HTML
 */
function parseHtml(text) {
    const preprocessed = preprocess(text);
    // We can safely only set getText because only this is used for parsing
    const parsedDoc = parser.parseHTMLDocument({ getText: () => preprocessed });
    return parsedDoc;
}
exports.parseHtml = parseHtml;
const createScanner = parser.createScanner;
/**
 * scan the text and remove any `>` or `<` that cause the tag to end short,
 */
function preprocess(text) {
    let scanner = createScanner(text);
    let token = scanner.scan();
    let currentStartTagStart = null;
    while (token !== vscode_html_languageservice_1.TokenType.EOS) {
        const offset = scanner.getTokenOffset();
        if (token === vscode_html_languageservice_1.TokenType.StartTagOpen) {
            currentStartTagStart = offset;
        }
        if (token === vscode_html_languageservice_1.TokenType.StartTagClose) {
            if (shouldBlankStartOrEndTagLike(offset)) {
                blankStartOrEndTagLike(offset);
            }
            else {
                currentStartTagStart = null;
            }
        }
        if (token === vscode_html_languageservice_1.TokenType.StartTagSelfClose) {
            currentStartTagStart = null;
        }
        // <Foo checked={a < 1}>
        // https://github.com/microsoft/vscode-html-languageservice/blob/71806ef57be07e1068ee40900ef8b0899c80e68a/src/parser/htmlScanner.ts#L327
        if (token === vscode_html_languageservice_1.TokenType.Unknown &&
            scanner.getScannerState() === vscode_html_languageservice_1.ScannerState.WithinTag &&
            scanner.getTokenText() === '<' &&
            shouldBlankStartOrEndTagLike(offset)) {
            blankStartOrEndTagLike(offset);
        }
        token = scanner.scan();
    }
    return text;
    function shouldBlankStartOrEndTagLike(offset) {
        // not null rather than falsy, otherwise it won't work on first tag(0)
        return (currentStartTagStart !== null &&
            utils_1.isInsideMoustacheTag(text, currentStartTagStart, offset));
    }
    function blankStartOrEndTagLike(offset) {
        text = text.substring(0, offset) + ' ' + text.substring(offset + 1);
        scanner = createScanner(text, offset, vscode_html_languageservice_1.ScannerState.WithinTag);
    }
}
//# sourceMappingURL=parseHtml.js.map